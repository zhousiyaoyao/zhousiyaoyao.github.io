<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZEUS ZHOU</title>
  
  <subtitle>Stay Hungry</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="zeuszhou.xyz/"/>
  <updated>2020-06-23T09:31:57.394Z</updated>
  <id>zeuszhou.xyz/</id>
  
  <author>
    <name>ZEUS ZHOU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>春招面经总结</title>
    <link href="zeuszhou.xyz/%E9%9D%A2%E8%AF%95/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    <id>zeuszhou.xyz/面试/春招面经总结/</id>
    <published>2020-06-23T09:01:43.000Z</published>
    <updated>2020-06-23T09:31:57.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>总结一下2020年春招，亲手经历的比较经典的面试题</p><h3 id="闭包题"><a href="#闭包题" class="headerlink" title="闭包题"></a>闭包题</h3><ol><li>实现一个函数，每次调用返回下一个质数，要求不使用全局变量，且函数本身不接受任何参数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getPrime = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(isPrime(count))&#123;</span><br><span class="line">      <span class="keyword">return</span> count</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getPrime()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">      <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ol><li><p>compose，函数式的写法和非函数式的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add1 = <span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> mul3 = <span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> div2 = <span class="function">(<span class="params">x</span>) =&gt;</span> x / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">x</span> =&gt;</span> fn.reduceRight(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span> cur(pre), x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">parameter</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = fn.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">      parameter = fn[i](parameter)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parameter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> operate = compose(div2, mul3, add1, add1)</span><br><span class="line"><span class="built_in">console</span>.log(operate(<span class="number">0</span>)) <span class="comment">// =&gt; 相当于 div2(mul3(add1(add1(0))))</span></span><br></pre></td></tr></table></figure></li><li><p>函数柯里化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...thisArgs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(args.length + thisArgs.length &lt; fn.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> curry(fn, ...thisArgs.concat(args))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, thisArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> add = curry(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c)</span><br><span class="line">  <span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><p>链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成语接龙</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wordschain</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> words = word</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">chain</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">        words += <span class="string">' -&gt; '</span> + word</span><br><span class="line">        <span class="keyword">return</span> chain</span><br><span class="line">    &#125;</span><br><span class="line">    chain.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> words</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="15-手写链式调用"><a href="#15-手写链式调用" class="headerlink" title="15. 手写链式调用"></a>15. 手写链式调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prototype[name] = fn</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a.method(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).</span><br><span class="line">method(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> nums = num;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twwo</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">nums += num;</span><br><span class="line"><span class="keyword">return</span> twwo;</span><br><span class="line">&#125;</span><br><span class="line">twwo.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> twwo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).sum())</span><br></pre></td></tr></table></figure><h3 id="Promise题"><a href="#Promise题" class="headerlink" title="Promise题"></a>Promise题</h3><h3 id="CSS题"><a href="#CSS题" class="headerlink" title="CSS题"></a>CSS题</h3><h3 id="Leetcode题"><a href="#Leetcode题" class="headerlink" title="Leetcode题"></a>Leetcode题</h3><h3 id="前端基础题"><a href="#前端基础题" class="headerlink" title="前端基础题"></a>前端基础题</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;总结一下2020年春招，亲手经历的比较经典的面试题&lt;/p&gt;
&lt;h3 id=&quot;闭包题&quot;&gt;&lt;a href=&quot;#闭包题&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="面试" scheme="zeuszhou.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="zeuszhou.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>hox原理解析加源码分析</title>
    <link href="zeuszhou.xyz/%E6%BA%90%E7%A0%81/hox%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8A%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>zeuszhou.xyz/源码/hox原理解析加源码分析/</id>
    <published>2020-06-23T07:17:41.000Z</published>
    <updated>2020-06-23T07:28:13.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>项目中用到了hox做状态管理，深入学习一下</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>众所周知，自定义hook无法进行数据共享，hox的出现正是为了解决这个问题。<br>hox只有一个api：createModel，包住自定义hook，可以实现全局model，数据共享。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>假设有一个自定义hook userInfo。createModel会创建一个Executor组件的实例，在其中执行userInfo，并把userInfo的结果缓存起来，最后返回一个新的hook：userInfoModel</p><p>userInfoModel订阅了Executor组件的数据，所以在多个组件中调用userInfoModel，拿到的数据都是同一份，也就是Executor中的state</p><p>流程：A组件触发事件，Executor组件的state发生改变，对Executor组件进行重渲染，然后通知A，B，C等组件拿到最新的数据进行渲染</p><p>本质就是一个单例模式，创建一个全局的Executor实例进行全局数据管理</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;项目中用到了hox做状态管理，深入学习一下&lt;/p&gt;
&lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="源码" scheme="zeuszhou.xyz/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="zeuszhou.xyz/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Redux初探</title>
    <link href="zeuszhou.xyz/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Redux%E5%88%9D%E6%8E%A2/"/>
    <id>zeuszhou.xyz/状态管理/Redux初探/</id>
    <published>2020-06-13T01:48:48.000Z</published>
    <updated>2020-06-13T04:39:15.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景概念学习"><a href="#背景概念学习" class="headerlink" title="背景概念学习"></a>背景概念学习</h3><p>Redux是flux架构的实现，受Elm启发，核心思想单向数据流<br>Redux is a predictable state container for JavaScript apps，可预测是因为reducer是一个纯函数<br>Flux概念：核心思想单项数据流，action -&gt; dispatcher -&gt; callback -&gt; store -&gt; react view -&gt; action<br>Elm概念：使用Model构建应用，也就是说Model是应用的核心。构建一个应用就是构建Model，构建更新Model的方式，以及如何构建Model到view的映射。</p><h3 id="三个基本概念"><a href="#三个基本概念" class="headerlink" title="三个基本概念"></a>三个基本概念</h3><ol><li>store<br>UI唯一的数据来源，react的state，store信息的变化会引起视图更新</li><li>action<br>用来表述发生了什么，必须拥有type属性，可选择携带数据</li><li>reducer<br>纯函数，根据action.type来作出反应，生成新的state来改变store</li></ol><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>UI发生变化，比如点击按钮 -&gt; action，描述点击了按钮 -&gt; reducer处理事件，得到新的state -&gt; store被更新 -&gt; UI响应store更新<br>state通过闭包的形式存放在store中，是只读的，如果要更改state，必须通过发送action进行，action是一个普通对象，react订阅store变化，并re-render视图</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>store.dispatch(action) 来触发reducer<br>store.getState() 获取当前state<br>store.subscribe(listener) store更新后回调listener，回调函数里面可以调用store.getStore()来获得更新后的state<br>store.subscribe(listener) 再调用一次，取消listener</p><h3 id="简化版redux实现"><a href="#简化版redux实现" class="headerlink" title="简化版redux实现"></a>简化版redux实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, initialState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = &#123;&#125;</span><br><span class="line">    store.state = initialState</span><br><span class="line">    store.listeners = []</span><br><span class="line">    store.subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        store.listeners.push(listener)</span><br><span class="line">    &#125;</span><br><span class="line">    store.dispatch = <span class="function">(<span class="params">store</span>) =&gt;</span> &#123;</span><br><span class="line">        store.state = reducer(store.state, action)</span><br><span class="line">        store.listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line">    store.getState = <span class="function"><span class="params">()</span> =&gt;</span> store.state</span><br><span class="line">    <span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h3><p>为什么出现？<br>因为redux只能针对同步且没有副作用的操作，如果存在副作用，比如ajax请求，就需要middleware的帮助</p><p>有无middleware的流程对比：<br>UI -&gt; action(plain) -&gt; reducer -&gt; state -&gt; UI<br>UI -&gt; action(side effect) -&gt; middleware -&gt; action(plain) -&gt; reducer -&gt; state -&gt; UI</p><p>middleware的作用：转换异步操作，生成原始的action，这样reducer函数可以处理相应的action，从而改变state，更新UI</p><h4 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h4><p>redux作者给出的中间件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> action(dispatch, getState, extraArgument)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next(action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = <span class="keyword">new</span> createThunkMiddleware()</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure></p><p>缺点：如果这个副作用action内部很复杂，需要给每个异步操作定义action，不易维护<br>流程：action(side effect) -&gt; redux-thunk监听 -&gt; 执行副作用函数 -&gt; action2(plain)</p><h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><p>redux-saga是控制执行的generator，在redux-saga中action是原始的js对象，把所有的异步副作用操作放在了saga函数里面<br>这样既统一了action的形式，又使得异步操作集中可以被集中处理</p><p>优点：action统一，可以集中处理异步操作，使用声明式的Effect，提供了更加细腻的控制流<br>流程：action1(plain) -&gt; redux-saga监听 -&gt; 执行相应的Effect方法 -&gt; 返回描述对象 -&gt; 恢复执行副作用函数 -&gt; action2(plain)<br>对比thunk，saga监听到action，不会立刻执行副作用，而是effect方法将其转换为一个描述对象，再将描述对象作为标识，再恢复执行副作用。<br>通过effect函数，可以方便测试，不需要effect函数的返回结果，只需要比较其返回的描述对象，与我们的期望描述对象是否相同</p><p>基础api：</p><ol><li>take，监听action，返回的是监听到的action对象</li><li>call，类似call，但是func可以是generator</li><li>put，类似于redux原始的dispatch</li><li>select，类似于redux的getState</li></ol><h3 id="Dva"><a href="#Dva" class="headerlink" title="Dva"></a>Dva</h3><p>是什么：<br>轻量封装，基于redux和redux-saga，内置react-react和fetch，内置loading，支持HMR</p><p>解决了什么问题：<br>redux书写麻烦，概念太多，文件分离，编辑成本高，不便于组织业务模型</p><h4 id="配合UMI"><a href="#配合UMI" class="headerlink" title="配合UMI"></a>配合UMI</h4><p>api：</p><ol><li>connect 绑定数据到组件</li><li>getDvaApp 获取dva实例</li><li>useDispatch 获取dispatch</li><li>useSelector 获取部分数据</li><li>useStore 获取store</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景概念学习&quot;&gt;&lt;a href=&quot;#背景概念学习&quot; class=&quot;headerlink&quot; title=&quot;背景概念学习&quot;&gt;&lt;/a&gt;背景概念学习&lt;/h3&gt;&lt;p&gt;Redux是flux架构的实现，受Elm启发，核心思想单向数据流&lt;br&gt;Redux is a predict
      
    
    </summary>
    
      <category term="状态管理" scheme="zeuszhou.xyz/categories/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="状态管理" scheme="zeuszhou.xyz/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>前端精读周刊</title>
    <link href="zeuszhou.xyz/%E5%89%8D%E7%AB%AF%E5%B9%BF%E5%BA%A6/%E5%89%8D%E7%AB%AF%E7%B2%BE%E8%AF%BB%E5%91%A8%E5%88%8A/"/>
    <id>zeuszhou.xyz/前端广度/前端精读周刊/</id>
    <published>2020-06-12T14:46:37.000Z</published>
    <updated>2020-06-14T02:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="纯函数和副作用"><a href="#纯函数和副作用" class="headerlink" title="纯函数和副作用"></a>纯函数和副作用</h3><p>副作用是指改变了其作用域外的状态<br>纯函数指的是函数的返回值仅仅由参数决定,当给同样的参数时,返回值是固定的，无其他API（包括Math, Date等）调用，无异步操作</p><h3 id="有状态和无状态"><a href="#有状态和无状态" class="headerlink" title="有状态和无状态"></a>有状态和无状态</h3><p>有状态指的是函数有自己的运行状态，可以修改自己的状态<br>无状态指的是函数不管理自己的数据或状态，结果取决于参数</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>[] 0 “” true<br>{} NaN “[object Object]” true<br>null 0 “null” false<br>undefined NaN “undefined” false</p><h3 id="状态管理库的对比"><a href="#状态管理库的对比" class="headerlink" title="状态管理库的对比"></a>状态管理库的对比</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;纯函数和副作用&quot;&gt;&lt;a href=&quot;#纯函数和副作用&quot; class=&quot;headerlink&quot; title=&quot;纯函数和副作用&quot;&gt;&lt;/a&gt;纯函数和副作用&lt;/h3&gt;&lt;p&gt;副作用是指改变了其作用域外的状态&lt;br&gt;纯函数指的是函数的返回值仅仅由参数决定,当给同样的参数时,返
      
    
    </summary>
    
      <category term="前端广度" scheme="zeuszhou.xyz/categories/%E5%89%8D%E7%AB%AF%E5%B9%BF%E5%BA%A6/"/>
    
    
      <category term="前端广度" scheme="zeuszhou.xyz/tags/%E5%89%8D%E7%AB%AF%E5%B9%BF%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>开发踩坑记录</title>
    <link href="zeuszhou.xyz/%E8%B8%A9%E5%9D%91/%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>zeuszhou.xyz/踩坑/开发踩坑记录/</id>
    <published>2020-06-12T07:13:17.000Z</published>
    <updated>2020-06-23T02:30:14.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录自己平时开发过程中的坑</p><h3 id="2020年6月的坑"><a href="#2020年6月的坑" class="headerlink" title="2020年6月的坑"></a>2020年6月的坑</h3><ol><li><p>chrome图片显示正常，safari和iphone看不到图片<br>原因：后台传的图片是webp，webp是谷歌开发的一种旨在加快图片加载速度的图片格式<br>图片压缩体积大约只有JPEG的2/3，说白了就是省空间。但safari不支持，转成png就ok了</p></li><li><p>微信网页登陆问题<br>扫码得到code，请求登陆接口报错，发现cookie没有带上，后面发现是因为前端后端的域名不是一样的，存在cookie跨域，后手动种cookie到测试环境，后又遇到参数错误问题，和中台同学沟通加上接口才得以解决。<br>启发：报错了就问，很多时候问题不是出在你身上，脸皮厚一点。cookie的domain，跨域机制需要理解</p></li><li><p>useEffect取消监听<br>feed下拉切换页面后仍然生效，发现监听位置写在了index，所以切换页面也不会销毁，写在组件里就可以了，注意useEffect取消监听，依赖不写</p></li><li><p>setState生效问题<br>set完state不会立刻生效，还是得用当前的值</p></li><li><p>前端传数组问题<br>数组需要用JSON.stringify，将数组对象转化成json字符串，否则会出现分开元素传递的奇怪现象</p></li><li><p>可替换参数问题<br>在hooks里，如果不需要render但参数需要替换，不要写在useState，直接写变量使用就可以</p></li><li><p>hooks用useState却不重新渲染组件问题<br>场景是用户发送评论，实时改变评论数和显示最新评论，评论是个对象，如果在更新函数里传入同一个对象时将无法触发更新。因为useState里数据务必为immutable（不可赋值的对象），解决思路就是通过slice() 返回一个新的对象去赋值。自加setCount(count + 1)</p></li><li><p>图片统一大小被拉伸问题<br>一句object-fit: cover解决问题，被替换的内容大小保持其宽高比，同时填充元素的整个内容框。 如果对象的宽高比与盒子的宽高比不匹配，该对象将被剪裁以适应。默认会是fill，表示拉伸以适应</p></li><li><p>微信内打开H5登陆报错误码10005<br>原因是微信内打开h5登陆微信的appid是微信公众号的，扫码登陆的appid是网页应用的</p></li><li><p>cookie跨域问题<br>cookie跨域的前提是根域得一样<br>cookie的domain表示可以访问此cookie的域名<br>假设2个域名为m.han.com 和han.com<br>在m.han.com设置cookie，不带domain属性，不会发送到han.com<br>在m.han.com设置cookie，带domain属性han.com，会发送到han.com，其他子域不可用<br>在m.han.com设置cookie，带domain属性.han.com，会发送到han.com，其他子域也可用<br>无论是客户端还是服务端，han.com都不能设置cookie到h.com</p></li></ol><p><em>客户端只会带上与请求同域的cookie</em></p><p>ajax同域请求默认会带cookie，但跨域默认不会带上cookie，客户端设置withCredentials为true才能跨域携带<br>fetch同域跨域都不会带，客户端设置credentials为include，跨域可以带，same-origin，同域可以带，omit任何请求都不带<br>Access-Control-Allow-Origin表示接受哪些域名的请求，发送cookie时，不能为*，必须指定域名<br>Access-Control-Allow-Credentials表示是否允许客户端发送cookie</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;记录自己平时开发过程中的坑&lt;/p&gt;
&lt;h3 id=&quot;2020年6月的坑&quot;&gt;&lt;a href=&quot;#2020年6月的坑&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="踩坑" scheme="zeuszhou.xyz/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="踩坑" scheme="zeuszhou.xyz/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>CSS3特性</title>
    <link href="zeuszhou.xyz/CSS/CSS3%E7%89%B9%E6%80%A7/"/>
    <id>zeuszhou.xyz/CSS/CSS3特性/</id>
    <published>2020-06-09T13:35:08.000Z</published>
    <updated>2020-06-10T01:57:23.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>比起前端的其他知识点，CSS容易被忽略，然而实际做项目中，CSS可真是太重要了，系统学一学对于开发效率来说有很大提升</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ol><li>E:nth-child(n)系列</li><li>E:enabled, E:disabled, E:checked</li><li>E:first-of-type系列,选择属于其父元素的首个E元素的每个E元素</li><li>[attribute^=value]系列，选择某元素attribute属性是以value开头的</li><li>E::selection: 选择被用户选取的元素部分</li></ol><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>元素改变样式的过渡效果<br>transition-property: 规定应用过渡的CSS属性的名称。<br>transition-duration: 规定完成过渡效果需要多长时间。<br>transition-delay: 规定过渡效果何时开始，默认是0。<br>transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有linear、ease-in、ease-out、ease-in-out和cubic-bezier等过渡类型。<br>transition: 简写属性，用于在一个属性中设置四个过渡属性。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个1s是持续时间，第二个是从何时开始</p><h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>Transform用来向元素应用各种2D和3D转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。</p><p>none: 定义不进行转换。<br>matrix(n,n,n,n,n,n): 定义2D转换，使用六个值的矩阵。<br>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义3D转换，使用16个值的4x4矩阵。<br>translate(x,y): 定义2D位移转换。<br>translate3d(x,y,z): 定义3D位移转换。<br>translateX(x): 定义位移转换，只是用X轴的值。<br>translateY(y): 定义位移转换，只是用Y轴的值。<br>translateZ(z): 定义3D位移转换，只是用Z轴的值。<br>scale(x,y): 定义2D缩放转换。<br>scale3d(x,y,z): 定义3D缩放转换。<br>scaleX(x): 通过设置X轴的值来定义缩放转换。<br>scaleY(y): 通过设置Y轴的值来定义缩放转换。<br>scaleZ(z): 通过设置Z轴的值来定义3D缩放转换。<br>rotate(angle): 定义2D旋转，在参数中规定角度。<br>rotate3d(x,y,z,angle): 定义3D旋转。<br>rotateX(angle): 定义沿着X轴的3D旋转。<br>rotateY(angle): 定义沿着Y轴的3D旋转。<br>rotateZ(angle): 定义沿着Z轴的3D旋转。<br>skew(x-angle,y-angle): 定义沿着X和Y轴的2D倾斜转换。<br>skewX(angle): 定义沿着X轴的2D倾斜转换。<br>skewY(angle): 定义沿着Y轴的2D倾斜转换。<br>perspective(n): 为3D转换元素定义透视视图。</p><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>CSS3的Animation制作动画我们可以省去复杂的js代码.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 旋转 */</span></span><br><span class="line">@<span class="keyword">keyframes</span> spin &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(0deg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: spin <span class="number">1s</span> linear infinite</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 弹幕 */</span></span><br><span class="line">@<span class="keyword">keyframes</span> bar &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">100%</span>;</span><br><span class="line">        transform: translate3d(0,0,0);;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-100%,0,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">animation</span>: bar <span class="number">1s</span> linear <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h3><p>border-radius 圆角<br>box-shadow 添加阴影<br>border-image 绘制边框</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>background-clip属性用于确定背景画区，通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围<br>background-origin，用于确定背景的位置，通常与background-position联合使用<br>background-size，常用来调整背景图片的大小<br>background-break，控制背景怎样在这些不同的盒子中显示</p><h3 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h3><p>word-wrap 属性允许您允许文本强制文本进行换行<br>text-overflow 设置或检索当当前行超过指定容器的边界时如何显示，ellipsis逗号<br>text-shadow 可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p><p>text-decoration CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置<br>text-fill-color: 设置文字内部填充颜色<br>text-stroke-color: 设置文字边界填充颜色<br>text-stroke-width: 设置文字边界宽度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;比起前端的其他知识点，CSS容易被忽略，然而实际做项目中，CSS可真是太重要了，系统学一学对于开发效率来说有很大提升&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
      <category term="CSS" scheme="zeuszhou.xyz/categories/CSS/"/>
    
    
      <category term="CSS" scheme="zeuszhou.xyz/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS和ES6 Module的区别</title>
    <link href="zeuszhou.xyz/%E6%A8%A1%E5%9D%97%E5%8C%96/CommonJS%E5%92%8CES6Module%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>zeuszhou.xyz/模块化/CommonJS和ES6Module的区别/</id>
    <published>2020-06-09T07:08:31.000Z</published>
    <updated>2020-06-09T08:11:22.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><ol><li>一个文件就是一个模块，第一次加载时，会在内存生成一个对象，以后再用到这个模块，直接从缓存取这个对象，除非清除缓存</li><li>require是同步的，适用于node端，浏览器端读取文件速度很慢，容易卡死</li><li>输出的是一个值的拷贝，一旦输出，输出的值发生变化，原来的值也不会变</li><li>运行时加载，加载时执行，当脚本被require，就会全部执行，一旦出现某个模块被循环加载，就只输出已经执行的部分，未执行的部分不会输出</li><li>this指向当前模块</li><li>不能require ES6模块</li></ol><h3 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h3><ol><li>ES6输出的是值的引用，输出的值发生变化，原来的值也会改变</li><li>ES6是编译时输出接口</li><li>this指向undefined</li><li>遇到循环引用，使用import加载一个变量，变量不会被缓存，真正取值时能拿到最终的值</li><li>支持加载commonjs</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CommonJS&quot;&gt;&lt;a href=&quot;#CommonJS&quot; class=&quot;headerlink&quot; title=&quot;CommonJS&quot;&gt;&lt;/a&gt;CommonJS&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;一个文件就是一个模块，第一次加载时，会在内存生成一个对象，以后再用到这个模块，直
      
    
    </summary>
    
      <category term="模块化" scheme="zeuszhou.xyz/categories/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
      <category term="模块化" scheme="zeuszhou.xyz/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="zeuszhou.xyz/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>zeuszhou.xyz/函数式编程/函数式编程/</id>
    <published>2020-06-08T13:28:56.000Z</published>
    <updated>2020-06-08T13:57:45.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>函数是一等公民<br>函数当成赋值给变量，当成参数传给函数或者当成返回值返回</li><li>只用表达式，不用语句，每一步都是纯运算，而且有返回值<br>表达式是单纯的运算过程，总有返回值<br>语句是执行某种操作，没有返回值</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;函数是一等公民&lt;br&gt;函数当成赋值给变量，当成参数传给函数或者当成返回值返回&lt;/li&gt;
&lt;li&gt;只用表达式，不用语句，每一步都是
      
    
    </summary>
    
      <category term="函数式编程" scheme="zeuszhou.xyz/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="zeuszhou.xyz/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>React hooks 再理解</title>
    <link href="zeuszhou.xyz/React/React-hooks-%E5%86%8D%E7%90%86%E8%A7%A3/"/>
    <id>zeuszhou.xyz/React/React-hooks-再理解/</id>
    <published>2020-06-08T13:18:16.000Z</published>
    <updated>2020-06-12T06:11:47.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一句话概括hooks：不编写class的情况下，使用state和其他react特性</p><h3 id="为什么要用hooks"><a href="#为什么要用hooks" class="headerlink" title="为什么要用hooks"></a>为什么要用hooks</h3><ol><li>class版本，组件之间复用状态逻辑很难，hooks可以在不改变组件结构的情况下复用状态逻辑</li><li>class版本，复杂组件变得难以理解，hooks将组件中相互关联的部分拆分的更小，并且舍去生命周期</li><li>class版本，class难以理解，需要考虑this，绑定事件</li><li>class版本，class无法很好的压缩，并且会使得热重载出现不稳定的情况</li><li>hooks组件不会被实例化，渲染性能得到提高</li></ol><h3 id="模拟生命周期（memo，useRef）"><a href="#模拟生命周期（memo，useRef）" class="headerlink" title="模拟生命周期（memo，useRef）"></a>模拟生命周期（memo，useRef）</h3><ol><li><p>shouldComponentUpdate<br>React.memo 包裹一个组件来对它的 props 进行浅比较<br>但这不是一个 hooks，因为它的写法和 hooks 不同<br>其实React.memo 等效于 PureComponent，但它只比较 props。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.memo(</span><br><span class="line">    _MyComponent,</span><br><span class="line">    (prevProps, nextProps) =&gt; nextProps.count !== prevProps.count</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>componentDidUpdate<br>useRef 在组件中创建“实例变量”<br>它作为一个标志来指示组件是否处于挂载或更新阶段<br>当组件更新完成后在会执行 else 里面的内容，以此来单独模拟 componentDidUpdate。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mounted = useRef()</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!mounted.current) &#123;</span><br><span class="line">        mounted.current = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"这里写代码"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>componentWillUnmount<br>当在 useEffect 的回调函数中返回一个函数时<br>这个函数会在组件卸载前被调用<br>我们可以在这里面清除定时器或事件监听器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"will mount"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></li></ol><h3 id="useState太多怎么办（useReducer）"><a href="#useState太多怎么办（useReducer）" class="headerlink" title="useState太多怎么办（useReducer）"></a>useState太多怎么办（useReducer）</h3><p>问：useState太多怎么办<br>答：对象属性赋值 or useReducer</p><p>相比于useState, useReducer</p><ol><li>更容易管理大量状态</li><li>更容易被其他开发者理解</li><li>更容易做测试, 所有的跟 state 相关的业务逻辑代码都可以放到一个单独的函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br><span class="line"><span class="comment">// diapatch 一个 action，使用 reducer 来更新 state</span></span><br></pre></td></tr></table></figure><h3 id="hooks如何模拟class组件的this（useRef）"><a href="#hooks如何模拟class组件的this（useRef）" class="headerlink" title="hooks如何模拟class组件的this（useRef）"></a>hooks如何模拟class组件的this（useRef）</h3><p>函数组件和class组件一个区别在于：函数组件可以捕获渲染时所用的值，而class组件用this会捕获到最新的值。<br>本质是因为react的props是immutable的，永远不会改变，而class组件的this是会变的，这也就意味着，this永远会拿最新的值。<br>所以问题来了</p><ol><li><p>用class组件如何拿到捕获渲染时所用的值<br>方法一：在调用事件前，读取this.props，然后显示传给回调函数<br>方法二：使用闭包，把this.props赋给props，然后操作props</p></li><li><p>用function组件如何拿到最新的值<br>使用ref，ref可以方便的保存任何值，类似于实例字段的方式，useRef在每次渲染后会返回同一个ref对象<br>变更.current属性不会引发组件重新渲染，所以current属性就像一个可以放东西的盒子，放最新的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pra</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [age, setAge] = useState()</span><br><span class="line">    <span class="keyword">const</span> lastAge = useRef();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        lastAge.current = age</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> showAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(lastAge.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>原理是在effect内部执行赋值操作，使得ref的值只有在dom更新之后再改变，确保了我们的变量突变不会破坏依赖于可中断渲染的事件切片和suspense等特性</p><h3 id="useCallback和useMemo的区别"><a href="#useCallback和useMemo的区别" class="headerlink" title="useCallback和useMemo的区别"></a>useCallback和useMemo的区别</h3><p>useCallback是用来优化对子组件的渲染，缓存函数的引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 在a，b不变的情况下，memoizedCallback的引用不变，所以这个入参函数会被缓存，从而起到优化渲染的效果</span></span><br></pre></td></tr></table></figure></p><p>useMemo是用来优化当前组件高开销的计算，缓存计算数据的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computeValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(count), [count]);</span><br><span class="line"><span class="comment">// 只有在count改变的时候，computeExpensiveValue才会重新执行</span></span><br></pre></td></tr></table></figure></p><h3 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h3><p>usePrevProps<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usePrevProps = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ref = useRef()</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ref.current = value</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ref.current</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> handleCount = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> previous = usePrevProps(handlecount)</span><br></pre></td></tr></table></figure></p><h3 id="PureComponent和React-memo"><a href="#PureComponent和React-memo" class="headerlink" title="PureComponent和React.memo"></a>PureComponent和React.memo</h3><ol><li><p>React.memo只适用于函数组件，如果组件在给定props的情况下渲染结果是相同的，可以包裹一个memo，react可以跳过渲染组件的操作直接复用最近一次渲染的结果<br>memo只检查props的变化，只会进行浅层对比，复杂对象可以传入第二个比较函数参数<br>和shouldComponentUpdate相反，如果props相等，会返回true，否则返回false</p></li><li><p>对比Component，React.PureComponent实现了shouldComponentUpdate，以浅对比prop和state的方式实现<br>如果state和props相同，render会渲染同样的内容，shouldComponentUpdate可以提高性能<br>但如果props和state是复杂的对象，会产生错误的结果</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一句话概括hooks：不编写class的情况下，使用state和其他react特性&lt;/p&gt;
&lt;h3 id=&quot;为什么要用hooks&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="React" scheme="zeuszhou.xyz/categories/React/"/>
    
    
      <category term="React" scheme="zeuszhou.xyz/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Promise代码专辑</title>
    <link href="zeuszhou.xyz/promise/Promise%E4%B8%93%E8%BE%91/"/>
    <id>zeuszhou.xyz/promise/Promise专辑/</id>
    <published>2020-06-07T05:05:49.000Z</published>
    <updated>2020-06-07T06:55:18.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Promise在前端的重要性不言而喻，手写promise代码在面试中出现的也越来越多，基本写不出来就拜拜了，还是得多敲一敲</p><h3 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h3><ol><li>自身属性value，reason，status，resolve的callback数组，reject的callback数组</li><li>resolve方法，status为pending时，赋值value，status，执行resolve全部方法</li><li>reject方法，status为pending时，赋值reason，status，执行reject全部方法</li><li>执行执行器函数</li><li>原型上定义then方法，传入resolve和reject作为参数</li><li>status为resolve，执行resolve，为reject，执行reject，为pending时，resolve加入resolve数组，reject加入reject数组</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    self.value = <span class="literal">undefined</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span></span><br><span class="line">    self.status = <span class="string">'pending'</span></span><br><span class="line">    self.resolveCallback = []</span><br><span class="line">    self.rejectCallback = []</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">            self.value = value</span><br><span class="line">            self.status = <span class="string">'resolved'</span></span><br><span class="line">            self.resolveCallback.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">                fn()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = <span class="string">'rejected'</span></span><br><span class="line">            self.rejectCallback.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">                fn()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'resolved'</span>)&#123;</span><br><span class="line">        resolve(self.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">        reject(self.reason)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        self.resolveCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve(self.value)</span><br><span class="line">        &#125;)</span><br><span class="line">        self.rejectCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            reject(self.reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all实现"><a href="#Promise-all实现" class="headerlink" title="Promise all实现"></a>Promise all实现</h3><ol><li>返回一个promise all，循环，每一个promise都resolve，再then</li><li>如果promise 成功了，count+1，value存到res，当count等于数组长度，代表都resolve完成了，resolve promise all，传入res</li><li>如果有promise reject了，直接reject promise all</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise_all</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject)&#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> res = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++)&#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                res[i] = value</span><br><span class="line">                <span class="keyword">if</span>(count === len)&#123;</span><br><span class="line">                    <span class="keyword">return</span> resolve(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,(reason) =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race实现"><a href="#Promise-race实现" class="headerlink" title="Promise race实现"></a>Promise race实现</h3><ol><li>和all唯一区别，当子promise成功的时候，直接resolve，传入value</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise_race</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++)&#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(value)</span><br><span class="line">            &#125;,(reason) =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-并发限制"><a href="#Promise-并发限制" class="headerlink" title="Promise 并发限制"></a>Promise 并发限制</h3><p>并发限制指的时每个时刻并发执行的promise数量是固定的，10w条并发请求，最终的执行结果也一样<br>promise不是调用promiseall时执行，而是实例化promise对象的时候执行<br>所以要并发限制，只能控制promise的实例化</p><ol><li>从array第一个元素开始，初始化promise，ret存初始化的promise，用一个executing数组保存正在执行的promise</li><li>不断初始化promise，直到limit</li><li>使用promise.race，获得executing中promise的执行情况，当有一个promise执行完毕，继续初始化promise并放入executing中</li><li>所有的promise都执行完毕后调用promise.all返回</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pool</span>(<span class="params">limit, array, func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> ret = [] <span class="comment">// promise数组</span></span><br><span class="line">    <span class="keyword">let</span> executing = [] <span class="comment">// promise执行数组</span></span><br><span class="line">    <span class="keyword">let</span> enqueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 当array为i时，直接resolve</span></span><br><span class="line">        <span class="keyword">if</span>(array.length === i)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每调用一次enqueue，初始化一个promise</span></span><br><span class="line">        <span class="keyword">let</span> item = array[i++]</span><br><span class="line">        <span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> func(item, array))</span><br><span class="line">        <span class="comment">// 放入promise数组</span></span><br><span class="line">        ret.push(p)</span><br><span class="line">        <span class="comment">// promise执行完毕，从executing数组删除</span></span><br><span class="line">        <span class="keyword">let</span> e = p.then(<span class="function"><span class="params">()</span> =&gt;</span> executing.splice(executing.indexOf(e),<span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 放入promise执行数组</span></span><br><span class="line">        executing.push(e)</span><br><span class="line">        <span class="comment">// 使用promise.race，当执行数组数量低于limit，实例化新的promise并执行</span></span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">        <span class="keyword">if</span> (executing.length &gt;= limit)&#123;</span><br><span class="line">            r = <span class="built_in">Promise</span>.race(executing)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r.then(<span class="function"><span class="params">()</span> =&gt;</span> enqueue())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueue().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.all(ret))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Promise在前端的重要性不言而喻，手写promise代码在面试中出现的也越来越多，基本写不出来就拜拜了，还是得多敲一敲&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="promise" scheme="zeuszhou.xyz/categories/promise/"/>
    
    
      <category term="promise" scheme="zeuszhou.xyz/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>Proxy和Reflect初探</title>
    <link href="zeuszhou.xyz/uncategorized/Proxy%E5%92%8CReflect%E5%88%9D%E6%8E%A2/"/>
    <id>zeuszhou.xyz/uncategorized/Proxy和Reflect初探/</id>
    <published>2020-06-02T01:44:51.000Z</published>
    <updated>2020-06-02T02:29:38.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>在访问对象之前建立一道拦截，任何访问该对象的操作都会通过这个拦截，执行proxy里的方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pro = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure></p><p>new proxy表示proxy实例，target表示要拦截的对象，handler表示拦截的方法</p><p>handler有13种：</p><ol><li>get(target, propKey, receiver) receiver可选</li><li>set(target, propKey, value, receiver) receiver可选</li><li>has</li><li>apply</li><li>ownKeys</li><li>construct</li><li>isExtensible</li><li>deleteProperty</li><li>defineProperty</li><li>getPropertyOf</li><li>setPropertyOf</li><li>preventExtensions</li><li>getOwnPropertyDescriptor</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"siyao"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get: <span class="function">(<span class="params">obj, name, </span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> name = <span class="string">"我喜欢"</span> + obj.name</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function">(<span class="params">obj, name, value, </span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"还名字了"</span>)</span><br><span class="line">        obj[name] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.create(proxy) <span class="comment">// 同上</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br><span class="line">obj.name = <span class="string">"xiangchan"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br></pre></td></tr></table></figure><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>ES6为操作对象而提供的API，用来调用对象的默认行为</p><ol><li>拥有proxy所有13种代理方法，静态形式存在，基本和Object同名方法相同，返回bool，语义性更好</li><li>无论proxy怎么修改默认行为，总是可以用Reflect对应的方法获取默认行为</li><li>修改某些Object方法的返回结果，使其更合理，比如Object.defineProperty无法定义属性会报错，Reflect.defineProperty会返回false</li><li>把Object操作变成函数行为，比如name in obj， delete obj[name]变成Reflect.deleteProperty和Reflect.has</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Proxy&quot;&gt;&lt;a href=&quot;#Proxy&quot; class=&quot;headerlink&quot; title=&quot;Proxy&quot;&gt;&lt;/a&gt;Proxy&lt;/h3&gt;&lt;p&gt;在访问对象之前建立一道拦截，任何访问该对象的操作都会通过这个拦截，执行proxy里的方法&lt;br&gt;&lt;figure cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS的知识点</title>
    <link href="zeuszhou.xyz/CSS/CSS%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>zeuszhou.xyz/CSS/CSS的知识点/</id>
    <published>2020-06-01T14:33:39.000Z</published>
    <updated>2020-06-09T13:35:23.491Z</updated>
    
    <content type="html"><![CDATA[<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><p>都是为了格式化文档树以外的信息，修饰不在文档树中的部分</p><p>伪类，单冒号，a:hover 表示鼠标覆盖样式； li:nth-child 表示n个li;</p><p>伪元素，双冒号，::before 让插入的内容出现在之前; ::after 让插入的内容出现在之后，可以用来清除浮动（clear both加上BFC）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;伪类和伪元素&quot;&gt;&lt;a href=&quot;#伪类和伪元素&quot; class=&quot;headerlink&quot; title=&quot;伪类和伪元素&quot;&gt;&lt;/a&gt;伪类和伪元素&lt;/h3&gt;&lt;p&gt;都是为了格式化文档树以外的信息，修饰不在文档树中的部分&lt;/p&gt;
&lt;p&gt;伪类，单冒号，a:hover 表示鼠标
      
    
    </summary>
    
      <category term="CSS" scheme="zeuszhou.xyz/categories/CSS/"/>
    
    
      <category term="CSS" scheme="zeuszhou.xyz/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JS对象方法总结</title>
    <link href="zeuszhou.xyz/JS%E5%9F%BA%E7%A1%80/Object%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>zeuszhou.xyz/JS基础/Object方法总结/</id>
    <published>2020-05-31T08:30:54.000Z</published>
    <updated>2020-05-31T14:30:48.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h3><ol><li><p>Object.assign<br>对象合并，浅拷贝，只拷贝自身属性，prototype不拷贝，视数组为对象进行处理，[1,2,3] + [4,5] = [4,5,3]</p></li><li><p>Object.create<br>使用指定的原型对象及其属性去创建一个新的对象</p></li><li><p>Object.defineProperties<br>直接在一个对象上修改一个或多个属性或者加属性（指的是内部属性）</p></li><li><p>Object.defineProperty<br>同上，单复数的区别</p></li></ol><p>数据描述符｜数据属性</p><ul><li>Configurable：表示能否通过delete删除此属性，能否修改内部属性值</li><li>Enumerable：表示该属性是否可枚举，是否可以通过for in或Object.keys()返回属性</li><li>Writable：表示能否修改属性的值</li><li>Value：表示该属性对应的值</li></ul><p>存取描述符｜访问器属性</p><ul><li>Configurable</li><li>Enumerable</li><li>get：访问对象属性时调用的函数</li><li>set：改变对象属性时调用的函数<br>使用defineProperty或者defineProperties时，属性默认为false或者undefined<br>用var定义的任何变量，该属性都是false<br>字面量定义的对象，该对象内部的属性的数据描述符属性都为true<br>当writable为true，configurable为false时，修改writable和value，不会报错<br>当writable为false，configurable为true时，value可以通过defineProperty修改，但不能直接赋值修改</li></ul><ol start="5"><li>Object.getOwnPropertyDescriptor</li><li><p>Object.getOwnPropertyDescriptors<br>返回指定对象上一个自有属性对应的属性描述符</p></li><li><p>Object.entries<br>返回键值对数组</p></li><li><p>obj.hasOwnProperty<br>对象自身属性是否有指定的属性</p></li><li><p>Object.keys<br>for in会枚举原型链上的属性，这个不会<br>不可枚举属性也不会打印</p></li><li><p>Object.values<br>会过滤属性名为 Symbol 值的属性</p></li><li><p>Object.getOwnPropertyNames<br>返回所有的属性，包括不可以枚举属性，但不包括属性名为 Symbol 值的属性</p></li><li><p>Object.getOwnPropertySymbols<br>返回所有Symbol属性的数组</p></li><li><p>Object.getPropertyOf<br>返回对象的原型</p></li><li><p>obj.isPrototypeOf<br>判断一个对象是否在另一个对象的原型链上</p></li><li><p>Object.setPrototypeOf<br>设置对象的原型对象</p></li><li><p>Object.is<br>判断两个值是否相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is([], []); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span>/<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">-0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Object.freeze<br>冻结一个对象，对象永远不可变</p></li><li><p>Object.isFrozen<br>判断是否冻结</p></li><li><p>Object.preventExtensions<br>对象不能添加新属性，可修改删除，不能添加</p></li><li><p>Object.isExtensible<br>判断对象是否可扩展，seal，freeze，preventExtensions都会使其不可扩展</p></li><li><p>Object.seal<br>密封对象，不能添加属性，不能配置，不可删除，但可以修改属性的值</p></li><li><p>Object.isSealed<br>判断对象是否被密封</p></li></ol><p>扩展（不能加属性） -&gt; 密封（不能配置，但可改值） -&gt; 冻结（不能修改值，所以啥都不能）</p><h3 id="Array方法"><a href="#Array方法" class="headerlink" title="Array方法"></a>Array方法</h3><ol><li>isArray 判断是否数组</li><li>toString 数组转字符串</li><li>valueof 返回对象原始值</li><li>join 数组转字符串</li><li>push </li><li>pop</li><li>unshift 添加头</li><li>shift 删除头</li><li>reverse</li><li>sort</li><li>concat</li><li>slice</li><li>splice</li><li>indexOf</li><li>every</li><li>filter</li><li>forEach</li><li>map</li><li>some</li><li>reduce</li><li>reduceRight</li><li>copyWithin 从数组的指定位置拷贝元素到数组的另一个指定位置中</li><li>entries</li><li>fill</li><li>find 返回符合传入测试（函数）条件的数组元素</li><li>findIndex 返回符合传入测试（函数）条件的数组元素索引</li><li>from 通过给定的对象中创建一个数组，比如set</li><li>includes 判断一个数组是否包含一个指定的值</li><li>keys</li><li>lastIndexOf</li></ol><h3 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h3><ol><li>charAt</li><li>charCodeAt</li><li>concat</li><li>slice</li><li>substr</li><li>substring</li><li>indexOf</li><li>lastIndexOf</li><li>toLowerCase</li><li>toUpperCase</li><li>match</li><li>search</li><li>replace</li><li>split</li><li>trim 去除字符串两边的空白</li><li>localeCompare 比较两个字符串的字符顺序</li><li>formCharCode</li><li>valueOf</li><li>includes</li><li>startsWith</li><li>endsWith</li><li>repeat</li><li>padStart 在头部补全字符串</li><li>padEnd 在尾部补全字符串</li></ol><h3 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h3><ol><li>Math.abs</li><li>Math.ceil</li><li>Math.floor</li><li>Math.max</li><li>Math.min</li><li>Math.pow(x,y) x的y次方</li><li>Math.random</li><li>Math.round</li><li>Math.sqrt</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Object方法&quot;&gt;&lt;a href=&quot;#Object方法&quot; class=&quot;headerlink&quot; title=&quot;Object方法&quot;&gt;&lt;/a&gt;Object方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Object.assign&lt;br&gt;对象合并，浅拷贝，只拷贝自身属性，pro
      
    
    </summary>
    
      <category term="JS基础" scheme="zeuszhou.xyz/categories/JS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JS基础" scheme="zeuszhou.xyz/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>React总结第一弹</title>
    <link href="zeuszhou.xyz/React/React%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
    <id>zeuszhou.xyz/React/React总结第一弹/</id>
    <published>2020-05-28T14:30:10.000Z</published>
    <updated>2020-05-31T08:29:37.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类组件中this指向问题"><a href="#类组件中this指向问题" class="headerlink" title="类组件中this指向问题"></a>类组件中this指向问题</h3><p>分为5种，所以还是函数组件好搞</p><ol><li>React.createClass，16版本已经废除，函数的this会自动绑定到组件，没了</li><li>Render函数中bind，组件每次执行render会重新分配函数，影响性能，会破坏purecomponent性能，不推荐</li><li>使用箭头函数，父组件刷新，都会生成一个新的箭头函数，子组件每次都会更新，和2一样，不推荐</li><li>构造函数中绑定this，父组件刷新，如果props值不变，子组件就不会刷新，推荐，就是可读性不太行</li><li>定义阶段使用箭头函数绑定，箭头函数会自动绑定到当前组件的作用域</li></ol><h3 id="关于antd表格渲染按钮"><a href="#关于antd表格渲染按钮" class="headerlink" title="关于antd表格渲染按钮"></a>关于antd表格渲染按钮</h3><p>在table的column中，直接写onclick函数回调会在渲染时直接调用，点击反而不能触发，需要改成箭头函数</p><h3 id="关于set-state"><a href="#关于set-state" class="headerlink" title="关于set state"></a>关于set state</h3><p>写翻页的时候，发现set完page，page并没有立刻改变，直接拿state发请求，page还是上次的page。原来set state只是把任务交给任务队列，本身并没有执行任务，所以在那个回调函数中，set了，page也不会立刻改变，state会被batchupdate，通过dom diff之后加入到组件实例。</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>react遍历数组一定要带上key，直接用map的index就行，不带会警告，帮助react优化渲染，使react只是重新排列而不是重新渲染它们，可以提供性能</p><h3 id="jsx的div问题"><a href="#jsx的div问题" class="headerlink" title="jsx的div问题"></a>jsx的div问题</h3><p>render函数或者三目运算，多个html元素一定要包一个div根元素，要不就报错了。<br>render函数返回一个react元素，是原生DOM组件的表示</p><h3 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h3><p>Refs提供一种访问在render方法中创建的DOM节点或者React元素的方法。<br>在典型数据流外，强制修改子代，这个时候可以使用Refs。<br>在input添加一个ref属性，该属性的值是一个回调函数，参数是DOM元素或者组件的挂载实例。<br>该函数接受输入的实际DOM元素，然后放在实例上，这样就可以在handleSubmit内部访问它。<br>在函数组件中，通过闭包使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomForm</span> (<span class="params">&#123;handleSubmit&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> inputElement</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">'text'</span></span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用场景：</p><ol><li>需要管理焦点，选择文本或媒体播放时</li><li>触发式动画</li><li>与第三方DOM库集成</li></ol><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>都是用来处理表单数据，推荐受控组件</p><ol><li>受控组件</li></ol><ul><li>包含表单的组件将跟踪其状态中的输入值，并在每次回调触发时重新渲染，以这种方式由React控制其值的输入表单元素称为受控组件</li><li>数据由React组件管理</li><li>表单元素默认映射到状态，双向绑定，用value绑定到state</li><li>必须使用onchange来绑定事件</li><li>支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式</li></ul><ol start="2"><li>非受控组件</li></ol><ul><li>非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值</li><li>数据由DOM节点来处理</li><li>容易和第三方库结合，更容易同时集成 React 和非 React 代码，可以减少代码量</li><li>适用场景只有一次性取值和submit验证，其他都推荐受控组件</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>componentWillMount：render之前执行<br>componentDidMount：render之后执行<br>componentWillReceiveProps：接到props之前执行<br>shouldComponentUpdate：返回true更新，如果不需要render，返回false，提高性能的方法<br>componentWillUpdate：shouldComponentUpdate返回true，更新之前执行<br>componentDidUpdate：更新dom以响应props和state的变化<br>componentWillUnmount：用于取消任何的网络请求，或删除与组件关联的所有事件监听器</p><h3 id="React-Context"><a href="#React-Context" class="headerlink" title="React Context"></a>React Context</h3><p>Context通过组件树提供一个传递数据的方法，从而避免在每一层手动的传递props属性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类组件中this指向问题&quot;&gt;&lt;a href=&quot;#类组件中this指向问题&quot; class=&quot;headerlink&quot; title=&quot;类组件中this指向问题&quot;&gt;&lt;/a&gt;类组件中this指向问题&lt;/h3&gt;&lt;p&gt;分为5种，所以还是函数组件好搞&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R
      
    
    </summary>
    
      <category term="React" scheme="zeuszhou.xyz/categories/React/"/>
    
    
      <category term="React" scheme="zeuszhou.xyz/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>TS总结（一）</title>
    <link href="zeuszhou.xyz/TypeScript/TS%E6%80%BB%E7%BB%93/"/>
    <id>zeuszhou.xyz/TypeScript/TS总结/</id>
    <published>2020-05-27T07:58:59.000Z</published>
    <updated>2020-05-28T06:33:45.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>codereview被ts搞得非常痛苦，需要好好学习一个</p><p>TS是静态类型化的js超集，静态性使其牛逼<br>语言在编译时报错是静态语言，运行时报错时动态语言<br>TS是静态弱类型语言，不是强类型，因为要兼容js，不限制js的隐式类型转换</p><p>使用TS的优点：</p><ul><li>可以避免低级错误，在编写时就能发现</li><li>减少多人合作的成本，适合大项目</li><li>良好的代码提示</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>TS的原始类型：</p><ol><li>boolean</li><li>number</li><li>string</li><li>null</li><li>undefined</li><li>symbol</li><li>void</li><li>bigint<br><strong>与js类型的区别</strong>，多了void和bigint，且都是小写开头</li></ol><p>TS的其他常见类型：</p><ol><li>any：不到万不得已，不要用，和js没有多少区别</li><li>unknown：any的安全类型，unknown类型值操作之前，要进行检查，而any不用。虽然可以是任何类型，但unknown不能被进行任何操作比如对象取值等等。可以用来缩小类型范围</li><li>never：永不存在的值的类型，任何类型的子类型，可以赋值给任何类型，但没有类型可以赋值给never（除了自己），也没有never的子类型。用于定义永远是空的数组，永远不会有返回值的函数，比如抛出异常。</li><li>数组：范型定义（const list: Array<number> = [1,2,3])，元素类型加[]，(const list: number[] = [1,2,3])</number></li><li>元组：严格版数组，但是元素的类型可以不同，let x: [string, number] = [‘hello’, 12]，元组可以push添加元素，但不能访问</li><li>object：普通对象，数组，枚举，元组都是object类型</li><li>枚举：声明一组命名的常数</li></ol><ul><li>数字枚举从0开始，依次加1，累加效应</li><li>字符串枚举可以用方括号取值（需要加双引号）也可以用点号取值</li><li>异构枚举，前两者混合，也可以但少见</li><li>正反向映射，可以用枚举名字取枚举值，也能用枚举值取枚举名字，原理是Direction[Direction[“Up”] = 10] = “Up”，所以up或者10都能取到</li><li>常量枚举，Up = ‘Up’，好处在于编译成js之后，直接省略了枚举，是性能提升的一个方案</li><li>字面量类型的情况，枚举的成员和枚举值可以当成类型使用</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>interface只能用于定义对象类型<br>可选属性：后面加?，可能是undefined<br>只读属性：前面加readonly，修改会给出警告<br>可索引类型：可以用来表示{北京：1}<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Phone &#123;</span><br><span class="line">    [name: string]: string</span><br><span class="line">&#125;</span><br><span class="line">interface User &#123;</span><br><span class="line">    name: string <span class="comment">// 普通</span></span><br><span class="line">    age?: number  <span class="comment">// 可选属性</span></span><br><span class="line">    readonly isMale: boolean <span class="comment">//只读属性</span></span><br><span class="line">    say: <span class="function"><span class="params">()</span> =&gt;</span> string <span class="comment">// 函数属性</span></span><br><span class="line">    phone: Phone <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>extends可以继承接口，在父接口的基础上，加上新的属性</p><h3 id="类和函数"><a href="#类和函数" class="headerlink" title="类和函数"></a>类和函数</h3><ol><li>abstract抽象类，无法实例化，被继承</li><li>public都能访问，private只能类内访问，protected只能类内和子类访问</li><li>类也可以作为接口</li><li>函数可以重载</li></ol><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义：在静态编写时不知道传入的参数到底是什么类型，只有在运行时传入参数才能确定，所以我们需要变量代表传入的类型，再返回这个变量，只用于表示类型而不表示值</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125; <span class="keyword">as</span> Person</span><br></pre></td></tr></table></figure><p>双重断言，先断成any再断成自己想要的</p><h3 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">arg: person | animal</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> person)&#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'age'</span> <span class="keyword">in</span> arg)&#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arg.kind === <span class="string">'foo'</span>)&#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合类型：中间用｜隔开，表示这些类型都可以</p><p>交叉类型：const result = <t &="" u="">{}</t></p><p>类型别名：type some = boolean | string</p><h3 id="React实战"><a href="#React实战" class="headerlink" title="React实战"></a>React实战</h3><ol><li>React.FC可以无需声明children属性的类型，会为props自动加上</li><li>input的onchange，e的类型为React.ChangeEvent<htmlinputelement>，就可以用e.target.value了</htmlinputelement></li><li>表单的submit，e的类型为React.FormEvent<htmlformelement></htmlformelement></li><li>当我们在组件中输入事件对应的名称时，会有相关的定义提示，我们只要用这个提示中的类型就可以了</li></ol><h3 id="索引类型查询"><a href="#索引类型查询" class="headerlink" title="索引类型查询"></a>索引类型查询</h3><p>keyof可以作用于泛型，来获取泛型所有的属性名构成联合属性<br>keyof可以取到索引类型的属性名，但还要获取属性值的类型，所以需要索引访问符，T[K]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Images</span> </span>&#123;</span><br><span class="line">    public src: string = <span class="string">'https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png'</span></span><br><span class="line">    public alt: string = <span class="string">'谷歌'</span></span><br><span class="line">    public width: number = <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line">type propsNames = keyof Images <span class="comment">// src | alt | width</span></span><br><span class="line">type propsType = Images[propsNames] <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line">function pick&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123;</span><br><span class="line">    <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = pick(user, [<span class="string">'token'</span>, <span class="string">'id'</span>, ])</span><br></pre></td></tr></table></figure><p>pick的例子，需要一个泛型T表示传入参数o的类型，因为编写时无法确定o是什么类型，第二个参数names表示数组的成员必须由参数o的属性名称构成，所以用keyof代表o类型的属性名的联合类型，所以用K约束到keyof T。返回值T[K]取到对应属性值的类型，T[K][]表示返回值的类型</p><h3 id="映射类型把接口成员都变成可选"><a href="#映射类型把接口成员都变成可选" class="headerlink" title="映射类型把接口成员都变成可选"></a>映射类型把接口成员都变成可选</h3><ol><li>一个一个在成员前加?</li><li>映射法</li></ol><p>语法：[K in Keys]<br>K对应每个属性名的类型，Keys表示一组属性名的类型，所以[K in keyof T]表示属性的类型，T[K]表示属性值的类型<br>结果：type partial<t> = { [K in keyof T]?: T[K] }</t></p><p>Q：找到一个接口中value为function的key和value<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FunctionPropertyNames&lt;T&gt; = &#123; [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="built_in">Function</span> ? K : never &#125;[keyof T]</span><br></pre></td></tr></table></figure></p><p>Partial可以把外层的属性都变成可选。处理深层需要递归<br>-?把可选属性变成必选，-readonly把只读属性变成非只读<br>Required把传入的属性变成必选项<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;;</span><br><span class="line"></span><br><span class="line">type DeepPartial&lt;T&gt; = &#123;</span><br><span class="line">    [U <span class="keyword">in</span> keyof T]?: T[U] extends object</span><br><span class="line">    ? DeepPartial&lt;T[U]&gt;</span><br><span class="line">    : T[U]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type Required&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]-?: T[P] &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="常见工具类型"><a href="#常见工具类型" class="headerlink" title="常见工具类型"></a>常见工具类型</h3><ul><li>Pick</li><li>Exclude</li><li>Omit</li><li>Compute</li><li>Merge</li><li>Intersection</li><li>Overwrite</li><li>Mutable<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T;</span><br><span class="line"><span class="keyword">type</span> T = Exclude&lt;<span class="number">1</span> | <span class="number">2</span>, <span class="number">1</span> | <span class="number">3</span>&gt; <span class="comment">// -&gt; 2  从T中排除出可分配给U的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Omit&lt;T, K&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</span><br><span class="line"><span class="keyword">type</span> Foo = Omit&lt;&#123;name: <span class="built_in">string</span>, age: <span class="built_in">number</span>&#125;, <span class="string">'name'</span>&gt; <span class="comment">// -&gt; &#123; age: number &#125; Omit忽略T中的某些属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Compute&lt;A <span class="keyword">extends</span> <span class="built_in">any</span>&gt; = A <span class="keyword">extends</span> <span class="built_in">Function</span> ? A : &#123; [K <span class="keyword">in</span> keyof A]: A[K] &#125; <span class="comment">// compute将交叉类型合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Merge&lt;O1 <span class="keyword">extends</span> object, O2 <span class="keyword">extends</span> object&gt; = Compute&lt;O1 &amp; Omit&lt;O2, keyof O1&gt;&gt; <span class="comment">// merge将两个对象的属性合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Intersection&lt;T <span class="keyword">extends</span> object, U <span class="keyword">extends</span> object&gt; = </span><br><span class="line">Pick&lt;T,Extract&lt;keyof T, keyof U&gt; &amp; Extract&lt;keyof U, keyof T&gt;&gt;;  <span class="comment">// Intersection取交集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Overwrite&lt;</span><br><span class="line">  T <span class="keyword">extends</span> object,</span><br><span class="line">  U <span class="keyword">extends</span> object,</span><br><span class="line">  I = Diff&lt;T, U&gt; &amp; Intersection&lt;U, T&gt;</span><br><span class="line">&gt; = Pick&lt;I, keyof I&gt;; <span class="comment">// 用U的属性覆盖T的相同属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutable&lt;T&gt; = &#123;</span><br><span class="line">  -readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125; <span class="comment">// 将T的所有属性的readonly移除</span></span><br></pre></td></tr></table></figure></li></ul><p>record允许从Union中创建新类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car = <span class="string">'Audi'</span> | <span class="string">'BMW'</span> | <span class="string">'MercedesBenz'</span></span><br><span class="line"><span class="keyword">type</span> CarList = Record&lt;Car, &#123;age: <span class="built_in">number</span>&#125;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cars: CarList = &#123;</span><br><span class="line">    Audi: &#123; age: <span class="number">119</span> &#125;,</span><br><span class="line">    BMW: &#123; age: <span class="number">113</span> &#125;,</span><br><span class="line">    MercedesBenz: &#123; age: <span class="number">133</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在tsx，如果<t>泛型被当成jsx标签，可以加上<t extends="" {}=""></t></t></p><h3 id="TS的编译原理"><a href="#TS的编译原理" class="headerlink" title="TS的编译原理"></a>TS的编译原理</h3><p>编译器的组成：</p><ol><li>Scanner扫描器</li><li>Parser解析器</li><li>Binder绑定器</li><li>Emitter发射器</li><li>Checker检查器</li></ol><p>处理过程：</p><ol><li>code + 扫描器 = token流 （词法分析）</li><li>token流 + 解析器 = AST抽象语法树 （语法分析）</li><li>AST + 绑定器 = Symbols符号 （语义分析）</li><li>AST + 符号 + 检查器 = 类型验证 （代码优化）</li><li>AST + 检查器 + 发射器 = JS代码 （目标代码生成）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;codereview被ts搞得非常痛苦，需要好好学习一个&lt;/p&gt;
&lt;p&gt;TS是静态类型化的js超集，静态性使其牛逼&lt;br&gt;语言在编译时报错是
      
    
    </summary>
    
      <category term="TypeScript" scheme="zeuszhou.xyz/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="zeuszhou.xyz/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结</title>
    <link href="zeuszhou.xyz/CS%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
    <id>zeuszhou.xyz/CS基础/操作系统总结/</id>
    <published>2020-05-26T09:32:59.000Z</published>
    <updated>2020-05-28T09:53:10.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>几次面试都是因为操作系统完全没看，非常尴尬，看到这些知识，想起了在武大的快乐时光，自己的操作系统课本都送人了，还是得总结一个</p><h3 id="OS四大特征"><a href="#OS四大特征" class="headerlink" title="OS四大特征"></a>OS四大特征</h3><ol><li>并发：同时发生（并行：不同时，但连续，交替执行）</li><li>共享：分互斥共享和同时共享，一段时间内只允许一个进程访问的资源叫做独占资源或者临界资源</li><li>异步：类似js的异步</li><li>虚拟：空分复用技术（虚拟存储器），时分复用技术（虚拟处理器）</li></ol><p>指令是CPU能识别和执行的最基本命令，分为特权指令和非特权指令，内核程序才能执行特权指令，普通程序执行非特权指令。<br>CPU也有内核态和用户态两种状态。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>定义： 进程是具有独立功能的程序在数据集合上运行的过程，分配资源的基本单位，内存地址空间相互独立</p><p>每个进程都有一个进程控制块PCB来描述进程的各种信息，包括PID，UID，状态，优先级，指针，寄存器值等等</p><p>进程的基本状态：运行（占有CPU，在CPU上运行），就绪（缺空闲CPU）和阻塞（等待某事件）<br>进程的另外2种2状态：创建态（正在初始化PCB），终止态（撤销PCB，资源回收）</p><p>状态转换：运行进入阻塞是主动的（系统调用），阻塞进入就绪是被动的（其他都弄好了，就差CPU了），阻塞不能直接进入运行，就绪也不能直接进入阻塞（因为运行时才能主动请求）</p><p>原语：不可被中断的原子操作，使用关中断指令和开中断指令实现，先关再开</p><p>进程的通信：</p><ol><li>共享存储：互斥的，内存画出一块共享区</li><li>管道：半双工，某一时间段只能实现单向传输，双向需要2个管道。字符流形式，管道写满时，write被阻塞，数据都读完时，read被阻塞。如果没写满，就不让读，没空就不让写。读进程只有一个。</li><li>消息传递：格式化的消息为单位，通过发送消息/接受消息两个原语进行通信，包括信息头和尾</li><li>间接通信：通过中介者信箱来进行通信</li></ol><p>同步：某些进程的执行必须先于另一些进程<br>互斥：当某个进程使用某种资源时，其他进程必须等待<br>信号量：解决进程的同步和互斥，由剩余资源和阻塞队列的地址组成<br>生成者消费者问题：生产者的作用是生成一定量数据到缓存区，消费者消耗这些数据，保证生产者不会在满时加入数据，消费者不会在空时消耗数据，用互斥信号量实现互斥访问，同步信号量表示还可以生成多少产品和消耗多少产品</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>定义：进程并发多个事件的能力，基本的CPU执行单位，程序执行流的最小单位，进程可以并发，进程的线程也可以并发，引入线程后，进程只作为除CPU外的系统资源分配单位。线程的切换比进程的切换开销小。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是计算机硬件与CPU沟通的桥梁，中转站，程序执行前要先放到内存中才能被CPU处理<br>CPU通过内存的存储单元编址来找到执行程序的数据</p><p>连续分配：用户进程分配必须是一个连续的内存空间，包括动态分区分配，缺点是会产生内存碎片<br>非连续分配<br>动态分区分配：不会预先划分内存分区，而是动态的建立分区</p><p>空闲分区表：分区号，分区大小，起始地址，状态<br>首次适应算法：每次从低地址开始查找，找到第一个满足大小的空闲分区<br>最佳适应算法：从空闲分区表中找到最小的适合分配的分区块来满足需求<br>基本分页存储：把内存空间分成一个个大小相等的分区，每个分区是一个页框，进程的页与内存的页有一一对应关系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;几次面试都是因为操作系统完全没看，非常尴尬，看到这些知识，想起了在武大的快乐时光，自己的操作系统课本都送人了，还是得总结一个&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="CS基础" scheme="zeuszhou.xyz/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="CS基础" scheme="zeuszhou.xyz/tags/CS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>BOM常见对象和方法总结</title>
    <link href="zeuszhou.xyz/%E6%B5%8F%E8%A7%88%E5%99%A8/JS%E5%B8%B8%E8%A7%81API%E6%80%BB%E7%BB%93/"/>
    <id>zeuszhou.xyz/浏览器/JS常见API总结/</id>
    <published>2020-05-25T15:36:45.000Z</published>
    <updated>2020-05-26T07:24:41.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>依然是取材于那一次不太满意的面试，setInterval误差问题和requestAnimationFrame，了解的很少，需要学习一下</p><h3 id="BOM对象总结"><a href="#BOM对象总结" class="headerlink" title="BOM对象总结"></a>BOM对象总结</h3><p>浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。<br>BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的自对象。</p><h4 id="Window对象方法"><a href="#Window对象方法" class="headerlink" title="Window对象方法"></a>Window对象方法</h4><ul><li>alert</li><li>requestAnimationFrame(callBack)：告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画</li><li>cancelAnimationFrame(callBack)：取消之前的动画帧请求</li><li>requestIdleCallback：在浏览器空闲期依次调用函数，这样可以把低优先级的任务不会导致动画和交互延迟触发</li><li>setImmediate(func)：把需要长时间运行的函数放到回调函数里，在浏览器完成后面的其他语句之后，立即执行这个回调</li><li>setInterval(callback)：重复调用一个函数或执行一个代码段，在每次调用之间有一定的事件延迟</li><li>clearInterval(intervalID)：取消用setInterval设置的重复定时任务</li><li>fetch：用于发起获取资源的请求，返回一个promise对象</li><li>postMessage：安全的实现跨源通信</li><li>getSelection：返回selection对象，表示用户选择的文本范围或者光标的当前位置</li></ul><p><strong>setInterval计时不准确问题</strong>：因为其回调函数不是到时执行，这个时间代表的是延迟多少秒，把回调函数放到异步队列，等待主线程空闲再被执行，如果这个callback过于耗时或者有其他耗时任务，会越来越不准确。</p><p>当使用setInterval时，<strong><em>仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中</em></strong>，这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。<strong><em>如果当前事件队列中，存在当前定时器的回调函数，即使到了规定的间隔事件，也不会把这个时间点的回调函数放到事件队列，这样的机制会导致一些间隔被跳过</em></strong>。</p><p>解决方法用迭代setTimeout,好处是在前一个定时器执行完之前，不会向队列插入新的定时器代码，确保没有缺失的间隔，而且可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。每次执行setTimeout，创建一个定时器，到达间隔时间时，把定时器回调加入队列，当主线程空闲时，可以执行这个回调函数，因为这个回调函数包含另一个setTimeout，因此可以把这个回调函数放到事件队列，这样执行上一个回调函数的时候，才会把下一个回调函数加入到队列，这样可以避免跳过某些时间点，也可以避免连续执行。<strong>因此setTimeout比setInterval稳定</strong></p><p>具体写法：计算一个offset，为当前时间减去开始时间，再减去count时间，nextTime为1000减去offset，如果小于0，nexttime为0，setTimeout这个方法，间隔为nextTime。从而计算出下次触发的时间，修正了当前触发的延迟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fix</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">var</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">var</span> nextTime = <span class="number">1000</span> - offset</span><br><span class="line">    <span class="keyword">if</span>(nextTime &lt; <span class="number">0</span>) nextTime = <span class="number">0</span></span><br><span class="line">    setTimeout(fix, nextTime);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(fix, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><strong>requestAnimationFrame三大好处</strong></p><ol><li>把每一帧的dom操作集中，一次重绘或回流中完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li><li>在隐藏或不可见的元素中，不会回流或重绘，意味着更少的CPU，GPU和内存使用量</li><li>浏览器专门为动画提供的api，在运行时浏览器会自动优化方法的调用，如果页面不是激活状态的话，动画会自动暂停，有效节省CPU的开销</li></ol><h4 id="Location对象方法"><a href="#Location对象方法" class="headerlink" title="Location对象方法"></a>Location对象方法</h4><ul><li>reload：重载来自当前URL的资源，可以接受一个布尔参数，为true表示一定会从服务器拿资源，如果是false或者没有，就可能来自缓存</li><li>assign：加载给定URL的内容资源到这个location对象所关联到对象</li><li>replace：用给定的URL替换掉当前的资源，与assign方法不同的是，replace替换掉的页面不会出现在history中，不能用回退回到该页面</li></ul><h4 id="History对象方法"><a href="#History对象方法" class="headerlink" title="History对象方法"></a>History对象方法</h4><ul><li>back：前往上一页，类似于go（-1），也就是页面返回按钮</li><li>forward：前往下一页，类似于go（1），也就是页面前进按钮</li><li>go：在当前页面的相对位置，从浏览记录加载页面</li><li>pushState：按指定的名称和URL把数据push进历史栈</li><li>replaceState：更新历史栈的记录</li><li>hashChange事件：location.hash触发，前端哈希路由的实现原理</li><li>popState事件：pushState或replaceState触发</li></ul><h4 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h4><ol><li>onLine属性：返回浏览器是否在线</li><li>battery属性：充电信息</li><li>connection属性：网络连接信息</li><li>geolocation属性：地理位置信息</li></ol><ul><li>vibrate（pattern）：调用设备的震动</li><li>getUserMedia（）：通过提示获取用户许可，返回一个音频或摄像头的调用</li></ul><h4 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h4><ol><li>availTop属性：返回屏幕上边有效的距离</li><li>availHeight属性：返回屏幕有效的高度</li></ol><ul><li>lockOrientation（orientation）：锁定屏幕到某个方向</li><li>unlockOrientation：解锁</li><li>onorientationchange：屏幕方向改变时触发事件</li></ul><h4 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h4><ul><li>createAttribute（name）：创建并返回一个新的属性节点</li><li>createDocumentFragment（）：创建一个新的空白的文档片段</li><li>createElement（tagName[,options]）：创建由tagname指定的html元素</li><li>querySelector（selectors）：返回文档中匹配指定的选择器组的第一个元素</li><li>write（markup）：将一个文本字符串写入由document.open（）打开的一个文档流</li><li>writeln（line）：同上，但会换行</li><li>append：在parentNode最后一个子节点之后插入一组Node对象或者DOMString对象</li><li>getAnimations：返回所运用的css动画，css过渡的元素集合</li><li>getElementsBy系列：不解释</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;依然是取材于那一次不太满意的面试，setInterval误差问题和requestAnimationFrame，了解的很少，需要学习一下&lt;/p
      
    
    </summary>
    
      <category term="浏览器" scheme="zeuszhou.xyz/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="zeuszhou.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Chrome浏览器</title>
    <link href="zeuszhou.xyz/%E6%B5%8F%E8%A7%88%E5%99%A8/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>zeuszhou.xyz/浏览器/Chrome浏览器/</id>
    <published>2020-05-25T13:15:07.000Z</published>
    <updated>2020-05-26T06:28:07.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天面了一个试，暴露出了很多问题，感觉自己有些知识建立在虚无缥缈之上，没有根基，也不连贯，还是需要多总结和学习。<br>面试官问了一下chrome的进程和线程，自己是凭感觉回答的，天天和chrome打交道，却不太了解有点不行，需要好好的学习一个。</p><h3 id="浏览器结构"><a href="#浏览器结构" class="headerlink" title="浏览器结构"></a>浏览器结构</h3><ol><li>用户界面</li><li>浏览器引擎</li><li>渲染引擎（Webkit，Blink，Trident）</li><li>网络模块</li><li>js引擎（V8）</li><li>界面后端</li><li>数据存储</li></ol><h3 id="多进程架构浏览器"><a href="#多进程架构浏览器" class="headerlink" title="多进程架构浏览器"></a>多进程架构浏览器</h3><p>Chrome浏览器使用多个进程来隔离不同的网页。因此在Chrome中打开一个网页相当于起了一个进程。<br>原因第一是安全，因为进程间不会共享资源和地址空间，而线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。<br>原因第二是把所有网页都放进一个进程的浏览器面临在健壮性，响应速度，安全性方面的挑战，一个tab崩，浏览器全崩</p><h3 id="Chrome的进程"><a href="#Chrome的进程" class="headerlink" title="Chrome的进程"></a>Chrome的进程</h3><p>打开chrome的任务管理器可以发现，他有很多进程</p><ol><li>浏览器进程，占用CPU最多，控制chrome应用程序，包括地址栏，书签，后退和前进按钮等，还有权限管理例如网络请求和文件访问</li><li>渲染器进程，控制选项卡内，网站里显示的全部内容</li><li>插件进程，chrome的插件，比如flash</li><li>GPU进程，专门用来处理GPU任务</li><li>扩展进程，执行的各种应用插件，例如掘金</li><li>标签页进程，每一个标签页也是一个进程</li><li>实用进程，比如网络或者声音</li></ol><h3 id="Chrome内核（渲染进程）的多线程"><a href="#Chrome内核（渲染进程）的多线程" class="headerlink" title="Chrome内核（渲染进程）的多线程"></a>Chrome内核（渲染进程）的多线程</h3><p>浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。每个tab网页都有由其独立的渲染引擎实例。</p><ol><li>GUI渲染线程，负责渲染html元素，当需要重绘或者回流时执行，js引擎会导致GUI引擎挂起，也就是冻结</li><li>js引擎线程，解析js脚本，运行代码</li><li>定时触发器线程，因为js是单线程，如果处于阻塞状态会影响计时的准确，因此需要单独的线程进行计时</li><li>事件触发线程，事件被触发时，事件线程会把事件添加到待处理事件的队尾，等待js引擎的处理。</li><li>异步http请求线程，在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</li></ol><p><strong>js引擎与GUI线程是互斥的</strong>：因为js可以操作dom，如果修改的同时渲染界面，那么渲染线程前后获得的元素数据就不一样。<br>所以当js执行时，gui会被挂起，gui更新会被保存到一个队列里，等引擎线程空闲时立即被执行。<br>所以JS执行的时间过长，就会造成页面的渲染不连贯。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天面了一个试，暴露出了很多问题，感觉自己有些知识建立在虚无缥缈之上，没有根基，也不连贯，还是需要多总结和学习。&lt;br&gt;面试官问了一下chr
      
    
    </summary>
    
      <category term="浏览器" scheme="zeuszhou.xyz/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="zeuszhou.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端设计模式</title>
    <link href="zeuszhou.xyz/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>zeuszhou.xyz/设计模式/前端设计模式/</id>
    <published>2020-05-23T09:49:17.000Z</published>
    <updated>2020-05-23T12:28:32.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><ol><li><strong>单一职责</strong>，一个程序只做一件事，功能过于复杂就取消，每个部分保持独立</li><li><strong>开放闭合原则</strong>，对扩展开放，对修改封闭，增加需求时，扩展新代码，而非修改已有代码</li><li><strong>里氏替换原则</strong>，子类能够覆盖父类，父类能出现的地方，子类就能出现</li><li><strong>接口隔离原则</strong>，保持接口的单一独立，类似单一职责原则，这里更关注接口</li><li><strong>依赖倒转原则</strong>，面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不关注具体类的实现</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个类只能构造出唯一的实例<br>比如弹窗，无论点击多少，都只被创建一次<br>实现方法为先判断实例存在与否，不存在创建再返回，存在直接返回，保证一个类只有一个实例</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>根据参数的不同可以命中不同的策略<br>两部分组成，策略类封装具体算法，环境类接受客户请求，随后将请求委托给某一个策略类</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理对象和本体对象具有一致的接口<br>为一个对象提供一个代用品或占位符，以便控制对它的访问<br>比如某一个花销很大的操作，可以先用虚拟代理的方式延迟到需要它的时候才创建，比如图片懒加载</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>能获取聚合对象的顺序和元素</p><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>PubSub</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>不同对象间约定好响应的接口</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式在对象间形成一致对待的树形结构</p><h3 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h3><p>父类中定好执行顺序</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>减少创建实例的个数</p><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>通过请求第一个条件，会持续执行后续的条件，直到返回结果为止</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>对象和对象之间借助第三方中介者进行通信<br>比如购物车需求，有商品选择表单，颜色选择表单和购买数量表单，都会触发change事件，可以通过中介者来转发处理这个事件</p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>动态的给函数赋能</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>每个状态建立一个类，状态改变会产生不同的行为</p><h3 id="适配者模式"><a href="#适配者模式" class="headerlink" title="适配者模式"></a>适配者模式</h3><p>一种数据结构改成另一种数据结构</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>当观察对象发生变化时，自动调用相关函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计模式原则&quot;&gt;&lt;a href=&quot;#设计模式原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式原则&quot;&gt;&lt;/a&gt;设计模式原则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;单一职责&lt;/strong&gt;，一个程序只做一件事，功能过于复杂就取消，每个部分保持
      
    
    </summary>
    
      <category term="设计模式" scheme="zeuszhou.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="zeuszhou.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>时尚版性能优化</title>
    <link href="zeuszhou.xyz/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>zeuszhou.xyz/性能优化/性能优化/</id>
    <published>2020-05-22T13:15:57.000Z</published>
    <updated>2020-05-23T02:51:07.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前端性能优化的目的不是追求一味的快，而是优化用户的体验，即使没有实质化的优化，让用户产生性能快的错觉，也是性能优化，用户觉得快，就是真的快，比如加loading。</p><h3 id="加载优化（大部分）"><a href="#加载优化（大部分）" class="headerlink" title="加载优化（大部分）"></a>加载优化（大部分）</h3><ol><li><strong>首屏loading</strong>：html-webpack-plugin，js执行期间加入提示，在文件中插入loading图</li><li><strong>预渲染</strong>：prerender-spa-plugin，模拟浏览器获取首屏的html结构，在本地模拟浏览器环境，预先执行我们的打包文件，这样通过解析可以获取首屏的html，在正常环境中，可以返回预先解析好的HTML</li><li><strong>开启HTTP2</strong>：浏览器并发限制一次性6次请求，http2二进制分帧进行通信，多路复用，只需一个tcp通道，请求和响应可以双向通信，头部压缩，只发送差异数据，维护头信息表，以后只发索引号。服务器推送，无需请求，减少多次请求的耗时</li><li><strong>开启浏览器缓存</strong>：给第三方库设置强缓存，SplitChunksPlugin来做拆包，需要将应用基础库和特定依赖库分离。当chunk在强缓存期但服务器代码变了，需要通知客户端，需要每次引入script脚本的时候去服务器更新，并开启hashchunk，作用是当chunk变化时，hash值也会变，所以不变就命中缓存，变了重新请求</li><li><strong>骨架图</strong>：antd的骨架屏Skeleton，vue的SkeletonWebpackPlugin，让骨架屏的css分离，直接作为内联style处理到html，提高载入速度</li><li><strong>Tree shaking</strong>：通过程序流分析找出你代码中无用的代码并剔除，webpack4自带，坑Babel转译，因为需要es5的module，需要手动关闭commonjs；坑2第三方库不可控，因为有些只有es5版本</li><li><strong>路由分割优化</strong>：只加载当前页面的代码，比如component: ()=&gt; import(‘@components/login’), 这样登陆页会被单独打包</li><li><strong>组件懒加载</strong>：在页面的加载中只渲染部分必须的组件,而其余的组件可以按需加载。基于lazy+suspense，比如把echart的图进行懒加载</li><li><strong>组件预加载</strong>：在用户的鼠标还处于hover状态的时候就开始触发图表资源的加载,通常情况下当用户点击结束之后,加载也基本完成,这个时候图表会很顺利地渲染出来,不会出现延迟</li><li><strong>keep alive</strong>：vue中，在页面跳转后不销毁组件，先保存组件对应的实例到内存，当页面需要再次渲染时，可以利用这个缓存。但实例过多容易出现内存泄漏，注意调用deactivated销毁。react官网宣布不会加类似api，但可以用redux状态缓存（不推荐），或者React Keep Alive这个库</li><li><strong>图片懒加载</strong>：页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域后再去加载。可见区域监听滚动事件</li><li><strong>资源压缩</strong>：服务端启动gzip</li><li><strong>CDN</strong>：静态资源走CDN，使用户就近获取内容，降低访问时延，减轻了源站的负载。静态资源不需要cookie，把静态资源和主页面置于不同的域名下，可以避免请求中携带不必要的cookie（同一个域名下的所有请求，都会携带一个相同的cookie，设置不当就会很大）</li><li><strong>雪碧图，icon</strong>：这个不解释</li></ol><h3 id="执行优化（小部分）"><a href="#执行优化（小部分）" class="headerlink" title="执行优化（小部分）"></a>执行优化（小部分）</h3><p>动画一般是性能的重灾区，需要大量的计算和渲染，主要有三种方式：</p><ol><li>Canvas</li><li>CSS3</li><li>Dom</li></ol><p>动画优化方案：</p><ol><li><strong>Dom优化之Dom+js</strong>：容易引起回流和重绘，优化就是不用Dom+js做动画</li><li><strong>CSS3优化之动画放在同一图层（合成层）</strong>：图层的概念，浏览器渲染页面，会把页面分成很多图层，对每个图层的节点计算样式，生成图形和位置，再把节点绘制到图层位图中，图层作为纹理上传至GPU，图层重组生成屏幕图像。将动画放在一个独立图层,这样可以避免动画效果影响其他渲染层的元素。比如iframe，video，3D或2D canvas，flash，3D transform，backface-visibility 为 hidden等</li><li><strong>CSS3优化之避免重绘和回流</strong>：多使用transform和opacity来实现动画效果</li><li><strong>CSS3优化之GPU加速</strong>：浏览器把一部分渲染任务丢给GPU。这部分css元素会提升到合成层，使得当页面上只有这个元素发生变换(transform)的时候其余元素不需要重新渲染。opacity，translate，rotate和scale会触发硬件加速，opacity号称性能最好的属性之一。</li><li><strong>CSS3优化之will change</strong>：will-change，最好的方式，设置为opacity，transform或上下左右，允许我们提前告知浏览器可能会对元素进行哪些操作，让浏览器去优化并提前处理那些潜在的比较消耗性能的操作比如在动画开始之前，提前处理元素的动画行为。过多使用会占用计算机资源，且需要留足够时间，变更失效需要移除。</li><li><strong>Canvas优化之requestAnimationFrame</strong>：setInterval定时完成动画不可靠，容易掉帧。requestAnimationFrame性能好，将所有动画放到一个浏览器重绘周期里去做，这样可以保存cpu循环次数，提高性能。开销更小，浏览器专门为动画提供的效果，运行时浏览器会自动优化方法的调用，如果页面不是激活状态，动画会暂停，节省了cpu开销</li><li><strong>Canvas优化之离屏canvas</strong>：离屏canvas当成一个缓存区。把需要重复绘制的画面数据进行缓存起来，减少调用 canvas的 API的消耗。</li><li><strong>Canvas优化之避免浮点运算</strong>：浮点数可能会使元素抖动或者抗锯齿失真</li><li><strong>Canvas优化之减少调用Canvas API</strong>：通过适量js原生计算减少canvas API的调用，粒子效果少用圆，最好用方形</li><li><strong>Web woker</strong>：分担主线程的压力</li></ol><p>大量数据性能优化方案：</p><ol><li><strong>虚拟列表</strong>：只渲染可视区域的数据，startIndex，endIndex，计算startOffset</li><li><strong>webwork</strong>：完全和UI线程（主线程）并行的执行js代码，从而不会阻塞UI，它和主线程是通过 onmessage 和 postMessage 接口进行通信的。当主线程在处理界面事件时，worker 可以在后台运行，帮你处理大量的数据计算，当计算完成，将计算结果返回给主线程，由主线程更新 DOM 元素</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前端性能优化的目的不是追求一味的快，而是优化用户的体验，即使没有实质化的优化，让用户产生性能快的错觉，也是性能优化，用户觉得快，就是真的快，
      
    
    </summary>
    
      <category term="性能优化" scheme="zeuszhou.xyz/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="zeuszhou.xyz/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
