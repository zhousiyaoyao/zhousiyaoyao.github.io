<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端算法面经题总结（长期更新）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 二叉树路径总和1234567891011121314151617181920212223242526// 返回bool 112var pathSum = function(root, sum) &#123; if(root === null) return false if(root.left === null &amp;&amp; root.right === null) return root.val == sum return pathSum(root.left, sum - root.val) || pathSum(root.right, sum - root.val) &#125;// 返回二维数组 113var pathSum = function(root, sum) &#123; let res = [] help(root, sum, res, []) return res&#125;function help(root, sum, res, arr) &#123; if(root === null)&#123; return &#125; arr.push(root.val) if(root.left === null &amp;&amp; root.right === null &amp;&amp; root.val === sum) &#123; res.push([...arr]) &#125; help(root.left, sum - root.val, res, arr) help(root.right, sum - root.val, res, arr) arr.pop()&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS手写面经题总结（长期更新）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2FCSS%E6%89%8B%E5%86%99%E9%9D%A2%E7%BB%8F%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.实现css弹幕1234567891011121314151617&lt;div class="block"&gt;我是弹幕&lt;/div&gt;.block&#123; position:absolute; animation:barrage 1s linear 5s; &#125; @keyframes barrage&#123; from&#123; left:100%; /* transform:translateX(0); */ &#125; to&#123; left:0; /* transform:translateX(100%); */ &#125; &#125; 2.实现图像旋转1234567891011@keyframes spin &#123; from &#123; transform: rotate(0deg) &#125; to &#123; transform: rotate(-360deg) &#125;&#125;div &#123; animation: spin 10s linear infinite&#125; 3.实现图片懒加载4.实现模态框]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React面经题总结（长期更新）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2FReact%E9%9D%A2%E7%BB%8F%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[setState的原理 react生命周期 虚拟dom diff算法]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS手写面经题总结（长期更新）]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2FJS%E6%89%8B%E5%86%99%E9%9D%A2%E7%BB%8F%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言JS的经典手写面试题 1.实现一个函数，每次调用返回下一个质数，要求不使用全局变量，且函数本身不接受任何参数123456789101112131415161718var getPrime = (function() &#123; var count = 1 return function() &#123; count = count + 1 if(isPrime(count))&#123; return count &#125;else&#123; return getPrime() &#125; &#125;&#125;)()function isPrime(n) &#123; for (let i = 2; i &lt; n; i++) if (n % i == 0) return false; return true;&#125; 2.compose，函数式的写法和非函数式的写法123456789101112131415161718const add1 = (x) =&gt; x + 1const mul3 = (x) =&gt; x * 3const div2 = (x) =&gt; x / 2function compose(...fn)&#123; return x =&gt; fn.reduceRight((pre,cur) =&gt; cur(pre), x)&#125;function compose(...fn)&#123; return function(parameter)&#123; for(var i = fn.length - 1; i &gt;= 0; i--)&#123; parameter = fn[i](parameter) &#125; return parameter &#125;&#125;const operate = compose(div2, mul3, add1, add1)console.log(operate(0)) // =&gt; 相当于 div2(mul3(add1(add1(0)))) 3.函数柯里化12345678910111213141516171819202122232425// es5展开版function curry(fn, ...thisArgs)&#123; return function(...args)&#123; if(args.length + thisArgs.length &lt; fn.length)&#123; return curry(fn, ...thisArgs.concat(args)) &#125; return fn.apply(this, thisArgs.concat(args)) &#125; &#125;const add = curry((a, b, c) =&gt; a + b + c)console.log(add(1,1)(2))// es5紧凑版function curry (fn, arr = []) &#123; return fn.length === arr.length ? fn.apply(null, arr) : function (...args) &#123; return curry (fn, arr.concat(args)) &#125;&#125;const add = curry((a, b, c) =&gt; a + b + c)console.log(add(1,1)(2))// es6一行版const curry = (fn, arr = []) =&gt; fn.length === arr.length ? fn(...arr) : (...args) =&gt; curry(fn, [...arr, ...args])const add = curry((a, b, c) =&gt; a + b + c)console.log(add(1,1)(2)) 4.链式调用1234567891011121314151617181920212223242526272829303132// 成语接龙function wordschain(word) &#123; var words = word function chain(word) &#123; words += ' -&gt; ' + word return chain &#125; chain.valueOf = function() &#123; return words &#125; return chain&#125;wordschain('胸有成竹')('竹报平安')('安富尊荣').valueOf()// 年龄var Person = function() &#123;&#125;;Person.prototype.set = function (age)&#123; this.age = 10; return this; //this调用位置决定其词法作用域&#125;Person.prototype.get = function ()&#123; var age = this.age; if(age &lt; 6)&#123; return '我还是个宝宝'; &#125;else if(age &lt; 18)&#123; return '我还是个少年'; &#125;else&#123; //…… &#125;&#125;var person = new Person();person.set(10).get(); // '我还是个少年' 5.防抖12345678910111213function debounce(func, wait) &#123; var timeout = null; return function()&#123; var context = this var args = arguments if(timeout)&#123; clearTimeout(timeout) &#125; timeout = setTimeout(function() &#123; func.apply(this, arguments) &#125;, wait) &#125;&#125; 6.节流三种写法123456789101112131415161718192021222324252627282930313233343536373839404142434445// 时间戳版，第一次执行，最后一次触发不执行function throttle(func, wait) &#123; var prev = Date.now() return function() &#123; var context = this var args = arguments var now = Date.now() if (now - prev &gt;= wait) &#123; func.apply(context, args) prev = Date.now() &#125; &#125;&#125;// 计时器版，第一次不执行，最后一次触发执行function throttle(func, wait) &#123; var timeout = null return function()&#123; var context = this var args = arguments if (!timeout) &#123; timeout = setTimeout(function()&#123; func.apply(context, args) timeout = null &#125;, wait) &#125; &#125;&#125;// 结合版，第一次执行，最后一次触发也执行function throttle(func, wait) &#123; var timout = null var prev = Date.now() return function() &#123; var now = Date.now() var context = this var args = arguments var remaining = wait - (now - prev) clearTimeout(timeout) if (remaining &lt;= 0) &#123; func.apply(context, args) now = Date.now() &#125; else &#123; timeout = setTimeout(func, remaining) &#125; &#125;&#125; 7.Promise最大并发数请求batchGet(arr, batchnum=3, timeout=3)123456789101112131415161718192021function batchGet(arr, batchnum, timeout, fetch) &#123; let i = 0 let ret = [] let executing = [] let enqueue = function() &#123; if(arr.length === i)&#123; return Promise.resolve &#125; let item = array[i++] let p = Promise.resolve.then(() =&gt; fetch(item)) ret.push(p) let e = p.then(() =&gt; executing.splice(executing.indexOf(e),1)) executing.push(e) let r = Promise.resolve() if (executing.length &gt;= batchnum) &#123; r = Promise.race(executing) &#125; return r.then(() =&gt; enqueue()) &#125; return enqueue().then(() =&gt; Promise.all(ret))&#125; 8.EventEmitter12345678910111213141516171819202122class EventEmitter &#123; constructor()&#123; this.topics = &#123;&#125; &#125; on (event, callback) &#123; this.topics[event] ? this.topics[event].push(callback) : this.topics[event] = [callback] &#125; emit (event, ...args) &#123; this.topics[event] &amp;&amp; this.topics[event].forEach(cb =&gt; cb(...args)) &#125; off (event) &#123; if (this.topics[event])&#123; delete this.topics[event] &#125; &#125; once (event, callback) &#123; this.on(event, (...args) -&gt; &#123; callback(...args) this.off(event) &#125;) &#125;&#125; 9. Reduce实现map1234567Array.prototype.map = function (callback) &#123; var arr = this return arr.reduce((acc, cur, i) =&gt; &#123; acc.push(callback(cur, i, arr)) return acc &#125;, [])&#125; 10. 手写双向绑定1234567891011121314151617let input = document.getElementById("Input");let text = document.getElementById("text");let data = &#123; value: ""&#125;Object.defineProperty(data, "value", &#123; set: function(val) &#123; text.innerHTML = val input.value = val &#125;, get: function() &#123; return input.value &#125;&#125;)input.oninput = function(e)&#123; data.value = e.target.value&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hox原理解析加源码分析]]></title>
    <url>%2F%E6%BA%90%E7%A0%81%2Fhox%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%8A%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言项目中用到了hox做状态管理，深入学习一下 作用众所周知，自定义hook无法进行数据共享，hox的出现正是为了解决这个问题。hox只有一个api：createModel，包住自定义hook，可以实现全局model，数据共享。 原理假设有一个自定义hook userInfo。createModel会创建一个Executor组件的实例，在其中执行userInfo，并把userInfo的结果缓存起来，最后返回一个新的hook：userInfoModel userInfoModel订阅了Executor组件的数据，所以在多个组件中调用userInfoModel，拿到的数据都是同一份，也就是Executor中的state 流程：A组件触发事件，Executor组件的state发生改变，对Executor组件进行重渲染，然后通知A，B，C等组件拿到最新的数据进行渲染 本质就是一个单例模式，创建一个全局的Executor实例进行全局数据管理 源码]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux初探]]></title>
    <url>%2F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2FRedux%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[背景概念学习Redux是flux架构的实现，受Elm启发，核心思想单向数据流Redux is a predictable state container for JavaScript apps，可预测是因为reducer是一个纯函数Flux概念：核心思想单项数据流，action -&gt; dispatcher -&gt; callback -&gt; store -&gt; react view -&gt; actionElm概念：使用Model构建应用，也就是说Model是应用的核心。构建一个应用就是构建Model，构建更新Model的方式，以及如何构建Model到view的映射。 三个基本概念 storeUI唯一的数据来源，react的state，store信息的变化会引起视图更新 action用来表述发生了什么，必须拥有type属性，可选择携带数据 reducer纯函数，根据action.type来作出反应，生成新的state来改变store 数据流UI发生变化，比如点击按钮 -&gt; action，描述点击了按钮 -&gt; reducer处理事件，得到新的state -&gt; store被更新 -&gt; UI响应store更新state通过闭包的形式存放在store中，是只读的，如果要更改state，必须通过发送action进行，action是一个普通对象，react订阅store变化，并re-render视图 APIstore.dispatch(action) 来触发reducerstore.getState() 获取当前statestore.subscribe(listener) store更新后回调listener，回调函数里面可以调用store.getStore()来获得更新后的statestore.subscribe(listener) 再调用一次，取消listener 简化版redux实现1234567891011121314const createStore = (reducer, initialState) =&gt; &#123; const store = &#123;&#125; store.state = initialState store.listeners = [] store.subscribe = (listener) =&gt; &#123; store.listeners.push(listener) &#125; store.dispatch = (store) =&gt; &#123; store.state = reducer(store.state, action) store.listeners.forEach(listener =&gt; listener()) &#125; store.getState = () =&gt; store.state return store&#125; Middleware为什么出现？因为redux只能针对同步且没有副作用的操作，如果存在副作用，比如ajax请求，就需要middleware的帮助 有无middleware的流程对比：UI -&gt; action(plain) -&gt; reducer -&gt; state -&gt; UIUI -&gt; action(side effect) -&gt; middleware -&gt; action(plain) -&gt; reducer -&gt; state -&gt; UI middleware的作用：转换异步操作，生成原始的action，这样reducer函数可以处理相应的action，从而改变state，更新UI redux-thunkredux作者给出的中间件123456789101112function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument) &#125; return next(action) &#125;&#125;const thunk = new createThunkMiddleware()thunk.withExtraArgument = createThunkMiddlewareexport default thunk 缺点：如果这个副作用action内部很复杂，需要给每个异步操作定义action，不易维护流程：action(side effect) -&gt; redux-thunk监听 -&gt; 执行副作用函数 -&gt; action2(plain) redux-sagaredux-saga是控制执行的generator，在redux-saga中action是原始的js对象，把所有的异步副作用操作放在了saga函数里面这样既统一了action的形式，又使得异步操作集中可以被集中处理 优点：action统一，可以集中处理异步操作，使用声明式的Effect，提供了更加细腻的控制流流程：action1(plain) -&gt; redux-saga监听 -&gt; 执行相应的Effect方法 -&gt; 返回描述对象 -&gt; 恢复执行副作用函数 -&gt; action2(plain)对比thunk，saga监听到action，不会立刻执行副作用，而是effect方法将其转换为一个描述对象，再将描述对象作为标识，再恢复执行副作用。通过effect函数，可以方便测试，不需要effect函数的返回结果，只需要比较其返回的描述对象，与我们的期望描述对象是否相同 基础api： take，监听action，返回的是监听到的action对象 call，类似call，但是func可以是generator put，类似于redux原始的dispatch select，类似于redux的getState Dva是什么：轻量封装，基于redux和redux-saga，内置react-react和fetch，内置loading，支持HMR 解决了什么问题：redux书写麻烦，概念太多，文件分离，编辑成本高，不便于组织业务模型 配合UMIapi： connect 绑定数据到组件 getDvaApp 获取dva实例 useDispatch 获取dispatch useSelector 获取部分数据 useStore 获取store]]></content>
      <categories>
        <category>状态管理</category>
      </categories>
      <tags>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端精读周刊]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%B9%BF%E5%BA%A6%2F%E5%89%8D%E7%AB%AF%E7%B2%BE%E8%AF%BB%E5%91%A8%E5%88%8A%2F</url>
    <content type="text"><![CDATA[纯函数和副作用副作用是指改变了其作用域外的状态纯函数指的是函数的返回值仅仅由参数决定,当给同样的参数时,返回值是固定的，无其他API（包括Math, Date等）调用，无异步操作 有状态和无状态有状态指的是函数有自己的运行状态，可以修改自己的状态无状态指的是函数不管理自己的数据或状态，结果取决于参数 隐式类型转换[] 0 “” true{} NaN “[object Object]” truenull 0 “null” falseundefined NaN “undefined” false 状态管理库的对比]]></content>
      <categories>
        <category>前端广度</category>
      </categories>
      <tags>
        <tag>前端广度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发踩坑记录]]></title>
    <url>%2F%E8%B8%A9%E5%9D%91%2F%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言记录自己平时开发过程中的坑 2020年6月的坑 chrome图片显示正常，safari和iphone看不到图片原因：后台传的图片是webp，webp是谷歌开发的一种旨在加快图片加载速度的图片格式图片压缩体积大约只有JPEG的2/3，说白了就是省空间。但safari不支持，转成png就ok了 微信网页登陆问题扫码得到code，请求登陆接口报错，发现cookie没有带上，后面发现是因为前端后端的域名不是一样的，存在cookie跨域，后手动种cookie到测试环境，后又遇到参数错误问题，和中台同学沟通加上接口才得以解决。启发：报错了就问，很多时候问题不是出在你身上，脸皮厚一点。cookie的domain，跨域机制需要理解 useEffect取消监听feed下拉切换页面后仍然生效，发现监听位置写在了index，所以切换页面也不会销毁，写在组件里就可以了，注意useEffect取消监听，依赖不写 setState生效问题set完state不会立刻生效，还是得用当前的值 前端传数组问题数组需要用JSON.stringify，将数组对象转化成json字符串，否则会出现分开元素传递的奇怪现象 可替换参数问题在hooks里，如果不需要render但参数需要替换，不要写在useState，直接写变量使用就可以 hooks用useState却不重新渲染组件问题场景是用户发送评论，实时改变评论数和显示最新评论，评论是个对象，如果在更新函数里传入同一个对象时将无法触发更新。因为useState里数据务必为immutable（不可赋值的对象），解决思路就是通过slice() 返回一个新的对象去赋值。自加setCount(count + 1) 图片统一大小被拉伸问题一句object-fit: cover解决问题，被替换的内容大小保持其宽高比，同时填充元素的整个内容框。 如果对象的宽高比与盒子的宽高比不匹配，该对象将被剪裁以适应。默认会是fill，表示拉伸以适应 微信内打开H5登陆报错误码10005原因是微信内打开h5登陆微信的appid是微信公众号的，扫码登陆的appid是网页应用的 cookie跨域问题cookie跨域的前提是根域得一样cookie的domain表示可以访问此cookie的域名假设2个域名为m.han.com 和han.com在m.han.com设置cookie，不带domain属性，不会发送到han.com在m.han.com设置cookie，带domain属性han.com，会发送到han.com，其他子域不可用在m.han.com设置cookie，带domain属性.han.com，会发送到han.com，其他子域也可用无论是客户端还是服务端，han.com都不能设置cookie到h.com 客户端只会带上与请求同域的cookie ajax同域请求默认会带cookie，但跨域默认不会带上cookie，客户端设置withCredentials为true才能跨域携带fetch同域跨域都不会带，客户端设置credentials为include，跨域可以带，same-origin，同域可以带，omit任何请求都不带Access-Control-Allow-Origin表示接受哪些域名的请求，发送cookie时，不能为*，必须指定域名Access-Control-Allow-Credentials表示是否允许客户端发送cookie]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3特性]]></title>
    <url>%2FCSS%2FCSS3%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言比起前端的其他知识点，CSS容易被忽略，然而实际做项目中，CSS可真是太重要了，系统学一学对于开发效率来说有很大提升 选择器 E:nth-child(n)系列 E:enabled, E:disabled, E:checked E:first-of-type系列,选择属于其父元素的首个E元素的每个E元素 [attribute^=value]系列，选择某元素attribute属性是以value开头的 E::selection: 选择被用户选取的元素部分 Transition元素改变样式的过渡效果transition-property: 规定应用过渡的CSS属性的名称。transition-duration: 规定完成过渡效果需要多长时间。transition-delay: 规定过渡效果何时开始，默认是0。transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有linear、ease-in、ease-out、ease-in-out和cubic-bezier等过渡类型。transition: 简写属性，用于在一个属性中设置四个过渡属性。123div &#123; transition: width 1s linear 2s;&#125; 第一个1s是持续时间，第二个是从何时开始 TransformTransform用来向元素应用各种2D和3D转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。 none: 定义不进行转换。matrix(n,n,n,n,n,n): 定义2D转换，使用六个值的矩阵。matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义3D转换，使用16个值的4x4矩阵。translate(x,y): 定义2D位移转换。translate3d(x,y,z): 定义3D位移转换。translateX(x): 定义位移转换，只是用X轴的值。translateY(y): 定义位移转换，只是用Y轴的值。translateZ(z): 定义3D位移转换，只是用Z轴的值。scale(x,y): 定义2D缩放转换。scale3d(x,y,z): 定义3D缩放转换。scaleX(x): 通过设置X轴的值来定义缩放转换。scaleY(y): 通过设置Y轴的值来定义缩放转换。scaleZ(z): 通过设置Z轴的值来定义3D缩放转换。rotate(angle): 定义2D旋转，在参数中规定角度。rotate3d(x,y,z,angle): 定义3D旋转。rotateX(angle): 定义沿着X轴的3D旋转。rotateY(angle): 定义沿着Y轴的3D旋转。rotateZ(angle): 定义沿着Z轴的3D旋转。skew(x-angle,y-angle): 定义沿着X和Y轴的2D倾斜转换。skewX(angle): 定义沿着X轴的2D倾斜转换。skewY(angle): 定义沿着Y轴的2D倾斜转换。perspective(n): 为3D转换元素定义透视视图。 AnimationCSS3的Animation制作动画我们可以省去复杂的js代码. 123456789101112131415161718192021222324252627/* 旋转 */@keyframes spin &#123; from &#123; transform: rotate(0deg) &#125; to &#123; transform: rotate(360deg) &#125;&#125;div &#123; animation: spin 1s linear infinite&#125;/* 弹幕 */@keyframes bar &#123; from &#123; left: 100%; transform: translate3d(0,0,0);; &#125; to &#123; left: 0; transform: translate3d(-100%,0,0); &#125;&#125;div &#123; position:absolute; animation: bar 1s linear 0s;&#125; Borderborder-radius 圆角box-shadow 添加阴影border-image 绘制边框 背景background-clip属性用于确定背景画区，通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围background-origin，用于确定背景的位置，通常与background-position联合使用background-size，常用来调整背景图片的大小background-break，控制背景怎样在这些不同的盒子中显示 文字效果word-wrap 属性允许您允许文本强制文本进行换行text-overflow 设置或检索当当前行超过指定容器的边界时如何显示，ellipsis逗号text-shadow 可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色 text-decoration CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置text-fill-color: 设置文字内部填充颜色text-stroke-color: 设置文字边界填充颜色text-stroke-width: 设置文字边界宽度]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS和ES6 Module的区别]]></title>
    <url>%2F%E6%A8%A1%E5%9D%97%E5%8C%96%2FCommonJS%E5%92%8CES6Module%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[CommonJS 一个文件就是一个模块，第一次加载时，会在内存生成一个对象，以后再用到这个模块，直接从缓存取这个对象，除非清除缓存 require是同步的，适用于node端，浏览器端读取文件速度很慢，容易卡死 输出的是一个值的拷贝，一旦输出，输出的值发生变化，原来的值也不会变 运行时加载，加载时执行，当脚本被require，就会全部执行，一旦出现某个模块被循环加载，就只输出已经执行的部分，未执行的部分不会输出 this指向当前模块 不能require ES6模块 ES6模块 ES6输出的是值的引用，输出的值发生变化，原来的值也会改变 ES6是编译时输出接口 this指向undefined 遇到循环引用，使用import加载一个变量，变量不会被缓存，真正取值时能拿到最终的值 支持加载commonjs]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程]]></title>
    <url>%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[特点 函数是一等公民函数当成赋值给变量，当成参数传给函数或者当成返回值返回 只用表达式，不用语句，每一步都是纯运算，而且有返回值表达式是单纯的运算过程，总有返回值语句是执行某种操作，没有返回值 没有副作用副作用指的是函数内部与外部互动，比如修改全局变量的值，产生运算以外的其他结果 引用透明函数的运行不依赖于外部变量或状态，只要输入的参数相同，所得的返回值总是相同 好处 代码简洁，开发快速 接近自然语言，易于理解 代码管理方便，每个函数可以当成独立单元 易于并发编程，不存在锁的问题 代码的热升级 具体应用1.]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React hooks 再理解]]></title>
    <url>%2FReact%2FReact-hooks-%E5%86%8D%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言一句话概括hooks：不编写class的情况下，使用state和其他react特性 为什么要用hooks class版本，组件之间复用状态逻辑很难，hooks可以在不改变组件结构的情况下复用状态逻辑 class版本，复杂组件变得难以理解，hooks将组件中相互关联的部分拆分的更小，并且舍去生命周期 class版本，class难以理解，需要考虑this，绑定事件 class版本，class无法很好的压缩，并且会使得热重载出现不稳定的情况 hooks组件不会被实例化，渲染性能得到提高 模拟生命周期（memo，useRef） shouldComponentUpdateReact.memo 包裹一个组件来对它的 props 进行浅比较但这不是一个 hooks，因为它的写法和 hooks 不同其实React.memo 等效于 PureComponent，但它只比较 props。 1234const MyComponent = React.memo( _MyComponent, (prevProps, nextProps) =&gt; nextProps.count !== prevProps.count) componentDidUpdateuseRef 在组件中创建“实例变量”它作为一个标志来指示组件是否处于挂载或更新阶段当组件更新完成后在会执行 else 里面的内容，以此来单独模拟 componentDidUpdate。 12345678const mounted = useRef()useEffect(() =&gt; &#123; if(!mounted.current) &#123; mounted.current = true &#125; else &#123; console.log("这里写代码") &#125;&#125;) componentWillUnmount当在 useEffect 的回调函数中返回一个函数时这个函数会在组件卸载前被调用我们可以在这里面清除定时器或事件监听器 12345useEffect(() =&gt; &#123; return () =&gt; &#123; console.log("will mount") &#125;&#125;, []) useState太多怎么办（useReducer）问：useState太多怎么办答：对象属性赋值 or useReducer 相比于useState, useReducer 更容易管理大量状态 更容易被其他开发者理解 更容易做测试, 所有的跟 state 相关的业务逻辑代码都可以放到一个单独的函数 12const [state, dispatch] = useReducer(reducer, initialArg, init);// diapatch 一个 action，使用 reducer 来更新 state hooks如何模拟class组件的this（useRef）函数组件和class组件一个区别在于：函数组件可以捕获渲染时所用的值，而class组件用this会捕获到最新的值。本质是因为react的props是immutable的，永远不会改变，而class组件的this是会变的，这也就意味着，this永远会拿最新的值。所以问题来了 用class组件如何拿到捕获渲染时所用的值方法一：在调用事件前，读取this.props，然后显示传给回调函数方法二：使用闭包，把this.props赋给props，然后操作props 用function组件如何拿到最新的值使用ref，ref可以方便的保存任何值，类似于实例字段的方式，useRef在每次渲染后会返回同一个ref对象变更.current属性不会引发组件重新渲染，所以current属性就像一个可以放东西的盒子，放最新的值 12345678910function Pra() &#123; const [age, setAge] = useState() const lastAge = useRef(); useEffect(()=&gt;&#123; lastAge.current = age &#125;) const showAge = () =&gt; &#123; console.log(lastAge.current) &#125;&#125; 原理是在effect内部执行赋值操作，使得ref的值只有在dom更新之后再改变，确保了我们的变量突变不会破坏依赖于可中断渲染的事件切片和suspense等特性 useCallback和useMemo的区别useCallback是用来优化对子组件的渲染，缓存函数的引用1234567const memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],);// 在a，b不变的情况下，memoizedCallback的引用不变，所以这个入参函数会被缓存，从而起到优化渲染的效果 useMemo是用来优化当前组件高开销的计算，缓存计算数据的值12const computeValue = useMemo(() =&gt; computeExpensiveValue(count), [count]);// 只有在count改变的时候，computeExpensiveValue才会重新执行 自定义hooksusePrevProps1234567891011const usePrevProps = value =&gt; &#123; const ref = useRef() useEffect(() =&gt; &#123; ref.current = value &#125;) return ref.current&#125;// 使用const [count, setCount] = useState(0);const handleCount = () =&gt; setCount(count + 1);const previous = usePrevProps(handlecount) PureComponent和React.memo React.memo只适用于函数组件，如果组件在给定props的情况下渲染结果是相同的，可以包裹一个memo，react可以跳过渲染组件的操作直接复用最近一次渲染的结果memo只检查props的变化，只会进行浅层对比，复杂对象可以传入第二个比较函数参数和shouldComponentUpdate相反，如果props相等，会返回true，否则返回false 对比Component，React.PureComponent实现了shouldComponentUpdate，以浅对比prop和state的方式实现如果state和props相同，render会渲染同样的内容，shouldComponentUpdate可以提高性能但如果props和state是复杂的对象，会产生错误的结果]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise代码专辑]]></title>
    <url>%2Fpromise%2FPromise%E4%B8%93%E8%BE%91%2F</url>
    <content type="text"><![CDATA[前言Promise在前端的重要性不言而喻，手写promise代码在面试中出现的也越来越多，基本写不出来就拜拜了，还是得多敲一敲 Promise实现 自身属性value，reason，status，resolve的callback数组，reject的callback数组 resolve方法，status为pending时，赋值value，status，执行resolve全部方法 reject方法，status为pending时，赋值reason，status，执行reject全部方法 执行执行器函数 原型上定义then方法，传入resolve和reject作为参数 status为resolve，执行resolve，为reject，执行reject，为pending时，resolve加入resolve数组，reject加入reject数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344function myPromise(executor)&#123; let self = this self.value = undefined self.reason = undefined self.status = 'pending' self.resolveCallback = [] self.rejectCallback = [] function resolve(value)&#123; if(self.status === 'pending')&#123; self.value = value self.status = 'resolved' self.resolveCallback.forEach(fn =&gt; &#123; fn() &#125;) &#125; &#125; function reject(reason)&#123; if(self.status === 'pending')&#123; self.reason = reason self.status = 'rejected' self.rejectCallback.forEach(fn =&gt; &#123; fn() &#125;) &#125; &#125; executor(resolve, reject)&#125;myPromise.prototype.then = function(resolve, reject)&#123; let self = this if(self.status === 'resolved')&#123; resolve(self.value) &#125; if(self.status === 'rejected')&#123; reject(self.reason) &#125; if(self.status === 'pending')&#123; self.resolveCallback.push(function()&#123; resolve(self.value) &#125;) self.rejectCallback.push(function()&#123; reject(self.reason) &#125;) &#125;&#125; Promise all实现 返回一个promise all，循环，每一个promise都resolve，再then 如果promise 成功了，count+1，value存到res，当count等于数组长度，代表都resolve完成了，resolve promise all，传入res 如果有promise reject了，直接reject promise all 1234567891011121314151617function promise_all(promises)&#123; return new Promise(resolve, reject)&#123; let count = 0 let res = [] for(let i = 0; i &lt; promises.length; i++)&#123; Promise.resolve(promises[i]).then((value) =&gt; &#123; count++ res[i] = value if(count === len)&#123; return resolve(res) &#125; &#125;,(reason) =&gt; &#123; return reject(reason) &#125;) &#125; &#125;&#125; Promise race实现 和all唯一区别，当子promise成功的时候，直接resolve，传入value 1234567891011function promise_race(promises)&#123; return new Promise(resolve, reject)&#123; for(let i = 0; i &lt; promises.length; i++)&#123; Promise.resolve(promises[i]).then((value) =&gt; &#123; return resolve(value) &#125;,(reason) =&gt; &#123; return reject(reason) &#125;) &#125; &#125;&#125; Promise 并发限制并发限制指的时每个时刻并发执行的promise数量是固定的，10w条并发请求，最终的执行结果也一样promise不是调用promiseall时执行，而是实例化promise对象的时候执行所以要并发限制，只能控制promise的实例化 从array第一个元素开始，初始化promise，ret存初始化的promise，用一个executing数组保存正在执行的promise 不断初始化promise，直到limit 使用promise.race，获得executing中promise的执行情况，当有一个promise执行完毕，继续初始化promise并放入executing中 所有的promise都执行完毕后调用promise.all返回 123456789101112131415161718192021222324252627function pool(limit, array, func)&#123; let i = 0 let ret = [] // promise数组 let executing = [] // promise执行数组 let enqueue = function()&#123; // 当array为i时，直接resolve if(array.length === i)&#123; return Promise.resolve &#125; // 每调用一次enqueue，初始化一个promise let item = array[i++] let p = Promise.resolve().then(() =&gt; func(item, array)) // 放入promise数组 ret.push(p) // promise执行完毕，从executing数组删除 let e = p.then(() =&gt; executing.splice(executing.indexOf(e),1)) // 放入promise执行数组 executing.push(e) // 使用promise.race，当执行数组数量低于limit，实例化新的promise并执行 let r = Promise.resolve() if (executing.length &gt;= limit)&#123; r = Promise.race(executing) &#125; return r.then(() =&gt; enqueue()) &#125; return enqueue().then(() =&gt; Promise.all(ret))&#125;]]></content>
      <categories>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy和Reflect初探]]></title>
    <url>%2Funcategorized%2FProxy%E5%92%8CReflect%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Proxy在访问对象之前建立一道拦截，任何访问该对象的操作都会通过这个拦截，执行proxy里的方法1let pro = new Proxy(target, handler) new proxy表示proxy实例，target表示要拦截的对象，handler表示拦截的方法 handler有13种： get(target, propKey, receiver) receiver可选 set(target, propKey, value, receiver) receiver可选 has apply ownKeys construct isExtensible deleteProperty defineProperty getPropertyOf setPropertyOf preventExtensions getOwnPropertyDescriptor 12345678910111213141516171819let obj = &#123; name: "siyao"&#125;let handler = &#123; get: (obj, name, ) =&gt; &#123; const name = "我喜欢" + obj.name return name &#125;, set: (obj, name, value, ) =&gt; &#123; console.log("还名字了") obj[name] = value return true &#125;&#125;let proxy = new Proxy(obj, handler)let newObj = Object.create(proxy) // 同上console.log(proxy.name)obj.name = "xiangchan"console.log(proxy.name) ReflectES6为操作对象而提供的API，用来调用对象的默认行为 拥有proxy所有13种代理方法，静态形式存在，基本和Object同名方法相同，返回bool，语义性更好 无论proxy怎么修改默认行为，总是可以用Reflect对应的方法获取默认行为 修改某些Object方法的返回结果，使其更合理，比如Object.defineProperty无法定义属性会报错，Reflect.defineProperty会返回false 把Object操作变成函数行为，比如name in obj， delete obj[name]变成Reflect.deleteProperty和Reflect.has]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS的知识点]]></title>
    <url>%2FCSS%2FCSS%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[伪类和伪元素都是为了格式化文档树以外的信息，修饰不在文档树中的部分 伪类，单冒号，a:hover 表示鼠标覆盖样式； li:nth-child 表示n个li; 伪元素，双冒号，::before 让插入的内容出现在之前; ::after 让插入的内容出现在之后，可以用来清除浮动（clear both加上BFC）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对象方法总结]]></title>
    <url>%2FJS%E5%9F%BA%E7%A1%80%2FObject%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Object方法 Object.assign对象合并，浅拷贝，只拷贝自身属性，prototype不拷贝，视数组为对象进行处理，[1,2,3] + [4,5] = [4,5,3] Object.create使用指定的原型对象及其属性去创建一个新的对象 Object.defineProperties直接在一个对象上修改一个或多个属性或者加属性（指的是内部属性） Object.defineProperty同上，单复数的区别 数据描述符｜数据属性 Configurable：表示能否通过delete删除此属性，能否修改内部属性值 Enumerable：表示该属性是否可枚举，是否可以通过for in或Object.keys()返回属性 Writable：表示能否修改属性的值 Value：表示该属性对应的值 存取描述符｜访问器属性 Configurable Enumerable get：访问对象属性时调用的函数 set：改变对象属性时调用的函数使用defineProperty或者defineProperties时，属性默认为false或者undefined用var定义的任何变量，该属性都是false字面量定义的对象，该对象内部的属性的数据描述符属性都为true当writable为true，configurable为false时，修改writable和value，不会报错当writable为false，configurable为true时，value可以通过defineProperty修改，但不能直接赋值修改 Object.getOwnPropertyDescriptor Object.getOwnPropertyDescriptors返回指定对象上一个自有属性对应的属性描述符 Object.entries返回键值对数组 obj.hasOwnProperty对象自身属性是否有指定的属性 Object.keysfor in会枚举原型链上的属性，这个不会不可枚举属性也不会打印 Object.values会过滤属性名为 Symbol 值的属性 Object.getOwnPropertyNames返回所有的属性，包括不可以枚举属性，但不包括属性名为 Symbol 值的属性 Object.getOwnPropertySymbols返回所有Symbol属性的数组 Object.getPropertyOf返回对象的原型 obj.isPrototypeOf判断一个对象是否在另一个对象的原型链上 Object.setPrototypeOf设置对象的原型对象 Object.is判断两个值是否相等 1234Object.is([], []); // falseObject.is(NaN, 0/0); // trueObject.is(0, -0); // falseObject.is(-0, -0); // true Object.freeze冻结一个对象，对象永远不可变 Object.isFrozen判断是否冻结 Object.preventExtensions对象不能添加新属性，可修改删除，不能添加 Object.isExtensible判断对象是否可扩展，seal，freeze，preventExtensions都会使其不可扩展 Object.seal密封对象，不能添加属性，不能配置，不可删除，但可以修改属性的值 Object.isSealed判断对象是否被密封 扩展（不能加属性） -&gt; 密封（不能配置，但可改值） -&gt; 冻结（不能修改值，所以啥都不能） Array方法 isArray 判断是否数组 toString 数组转字符串 valueof 返回对象原始值 join 数组转字符串 push pop unshift 添加头 shift 删除头 reverse sort concat slice splice indexOf every filter forEach map some reduce reduceRight copyWithin 从数组的指定位置拷贝元素到数组的另一个指定位置中 entries fill find 返回符合传入测试（函数）条件的数组元素 findIndex 返回符合传入测试（函数）条件的数组元素索引 from 通过给定的对象中创建一个数组，比如set includes 判断一个数组是否包含一个指定的值 keys lastIndexOf String方法 charAt charCodeAt concat slice substr substring indexOf lastIndexOf toLowerCase toUpperCase match search replace split trim 去除字符串两边的空白 localeCompare 比较两个字符串的字符顺序 formCharCode valueOf includes startsWith endsWith repeat padStart 在头部补全字符串 padEnd 在尾部补全字符串 Math方法 Math.abs Math.ceil Math.floor Math.max Math.min Math.pow(x,y) x的y次方 Math.random Math.round Math.sqrt]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React总结第一弹]]></title>
    <url>%2FReact%2FReact%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[类组件中this指向问题分为5种，所以还是函数组件好搞 React.createClass，16版本已经废除，函数的this会自动绑定到组件，没了 Render函数中bind，组件每次执行render会重新分配函数，影响性能，会破坏purecomponent性能，不推荐 使用箭头函数，父组件刷新，都会生成一个新的箭头函数，子组件每次都会更新，和2一样，不推荐 构造函数中绑定this，父组件刷新，如果props值不变，子组件就不会刷新，推荐，就是可读性不太行 定义阶段使用箭头函数绑定，箭头函数会自动绑定到当前组件的作用域 关于antd表格渲染按钮在table的column中，直接写onclick函数回调会在渲染时直接调用，点击反而不能触发，需要改成箭头函数 关于set state写翻页的时候，发现set完page，page并没有立刻改变，直接拿state发请求，page还是上次的page。原来set state只是把任务交给任务队列，本身并没有执行任务，所以在那个回调函数中，set了，page也不会立刻改变，state会被batchupdate，通过dom diff之后加入到组件实例。 keyreact遍历数组一定要带上key，直接用map的index就行，不带会警告，帮助react优化渲染，使react只是重新排列而不是重新渲染它们，可以提供性能 jsx的div问题render函数或者三目运算，多个html元素一定要包一个div根元素，要不就报错了。render函数返回一个react元素，是原生DOM组件的表示 RefsRefs提供一种访问在render方法中创建的DOM节点或者React元素的方法。在典型数据流外，强制修改子代，这个时候可以使用Refs。在input添加一个ref属性，该属性的值是一个回调函数，参数是DOM元素或者组件的挂载实例。该函数接受输入的实际DOM元素，然后放在实例上，这样就可以在handleSubmit内部访问它。在函数组件中，通过闭包使用。1234567891011function CustomForm (&#123;handleSubmit&#125;) &#123; let inputElement return ( &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt; &lt;input type='text' ref=&#123;(input) =&gt; inputElement = input&#125; /&gt; &lt;button type='submit'&gt;Submit&lt;/button&gt; &lt;/form&gt; )&#125; 使用场景： 需要管理焦点，选择文本或媒体播放时 触发式动画 与第三方DOM库集成 受控组件和非受控组件都是用来处理表单数据，推荐受控组件 受控组件 包含表单的组件将跟踪其状态中的输入值，并在每次回调触发时重新渲染，以这种方式由React控制其值的输入表单元素称为受控组件 数据由React组件管理 表单元素默认映射到状态，双向绑定，用value绑定到state 必须使用onchange来绑定事件 支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式 非受控组件 非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值 数据由DOM节点来处理 容易和第三方库结合，更容易同时集成 React 和非 React 代码，可以减少代码量 适用场景只有一次性取值和submit验证，其他都推荐受控组件 生命周期componentWillMount：render之前执行componentDidMount：render之后执行componentWillReceiveProps：接到props之前执行shouldComponentUpdate：返回true更新，如果不需要render，返回false，提高性能的方法componentWillUpdate：shouldComponentUpdate返回true，更新之前执行componentDidUpdate：更新dom以响应props和state的变化componentWillUnmount：用于取消任何的网络请求，或删除与组件关联的所有事件监听器 React ContextContext通过组件树提供一个传递数据的方法，从而避免在每一层手动的传递props属性]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TS总结（一）]]></title>
    <url>%2FTypeScript%2FTS%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言codereview被ts搞得非常痛苦，需要好好学习一个 TS是静态类型化的js超集，静态性使其牛逼语言在编译时报错是静态语言，运行时报错时动态语言TS是静态弱类型语言，不是强类型，因为要兼容js，不限制js的隐式类型转换 使用TS的优点： 可以避免低级错误，在编写时就能发现 减少多人合作的成本，适合大项目 良好的代码提示 类型TS的原始类型： boolean number string null undefined symbol void bigint与js类型的区别，多了void和bigint，且都是小写开头 TS的其他常见类型： any：不到万不得已，不要用，和js没有多少区别 unknown：any的安全类型，unknown类型值操作之前，要进行检查，而any不用。虽然可以是任何类型，但unknown不能被进行任何操作比如对象取值等等。可以用来缩小类型范围 never：永不存在的值的类型，任何类型的子类型，可以赋值给任何类型，但没有类型可以赋值给never（除了自己），也没有never的子类型。用于定义永远是空的数组，永远不会有返回值的函数，比如抛出异常。 数组：范型定义（const list: Array = [1,2,3])，元素类型加[]，(const list: number[] = [1,2,3]) 元组：严格版数组，但是元素的类型可以不同，let x: [string, number] = [‘hello’, 12]，元组可以push添加元素，但不能访问 object：普通对象，数组，枚举，元组都是object类型 枚举：声明一组命名的常数 数字枚举从0开始，依次加1，累加效应 字符串枚举可以用方括号取值（需要加双引号）也可以用点号取值 异构枚举，前两者混合，也可以但少见 正反向映射，可以用枚举名字取枚举值，也能用枚举值取枚举名字，原理是Direction[Direction[“Up”] = 10] = “Up”，所以up或者10都能取到 常量枚举，Up = ‘Up’，好处在于编译成js之后，直接省略了枚举，是性能提升的一个方案 字面量类型的情况，枚举的成员和枚举值可以当成类型使用 接口interface只能用于定义对象类型可选属性：后面加?，可能是undefined只读属性：前面加readonly，修改会给出警告可索引类型：可以用来表示{北京：1}12345678910interface Phone &#123; [name: string]: string&#125;interface User &#123; name: string // 普通 age?: number // 可选属性 readonly isMale: boolean //只读属性 say: () =&gt; string // 函数属性 phone: Phone // &#125; extends可以继承接口，在父接口的基础上，加上新的属性 类和函数 abstract抽象类，无法实例化，被继承 public都能访问，private只能类内访问，protected只能类内和子类访问 类也可以作为接口 函数可以重载 泛型定义：在静态编写时不知道传入的参数到底是什么类型，只有在运行时传入参数才能确定，所以我们需要变量代表传入的类型，再返回这个变量，只用于表示类型而不表示值 类型断言12345interface Person &#123; name: string; age: number&#125;const person = &#123;&#125; as Person 双重断言，先断成any再断成自己想要的 类型守卫1234567891011function a(arg: person | animal)&#123; if(arg instanceof person)&#123; xxx &#125; if('age' in arg)&#123; xxx &#125; if(arg.kind === 'foo')&#123; xxx &#125;&#125; 联合类型：中间用｜隔开，表示这些类型都可以 交叉类型：const result = {} 类型别名：type some = boolean | string React实战 React.FC可以无需声明children属性的类型，会为props自动加上 input的onchange，e的类型为React.ChangeEvent，就可以用e.target.value了 表单的submit，e的类型为React.FormEvent 当我们在组件中输入事件对应的名称时，会有相关的定义提示，我们只要用这个提示中的类型就可以了 索引类型查询keyof可以作用于泛型，来获取泛型所有的属性名构成联合属性keyof可以取到索引类型的属性名，但还要获取属性值的类型，所以需要索引访问符，T[K] 12345678910111213class Images &#123; public src: string = 'https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png' public alt: string = '谷歌' public width: number = 500&#125;type propsNames = keyof Images // src | alt | widthtype propsType = Images[propsNames] // string | numberfunction pick&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123; return names.map(n =&gt; o[n]);&#125;const res = pick(user, ['token', 'id', ]) pick的例子，需要一个泛型T表示传入参数o的类型，因为编写时无法确定o是什么类型，第二个参数names表示数组的成员必须由参数o的属性名称构成，所以用keyof代表o类型的属性名的联合类型，所以用K约束到keyof T。返回值T[K]取到对应属性值的类型，T[K][]表示返回值的类型 映射类型把接口成员都变成可选 一个一个在成员前加? 映射法 语法：[K in Keys]K对应每个属性名的类型，Keys表示一组属性名的类型，所以[K in keyof T]表示属性的类型，T[K]表示属性值的类型结果：type partial = { [K in keyof T]?: T[K] } Q：找到一个接口中value为function的key和value1type FunctionPropertyNames&lt;T&gt; = &#123; [K in keyof T]: T[K] extends Function ? K : never &#125;[keyof T] Partial可以把外层的属性都变成可选。处理深层需要递归-?把可选属性变成必选，-readonly把只读属性变成非只读Required把传入的属性变成必选项123456789type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;type DeepPartial&lt;T&gt; = &#123; [U in keyof T]?: T[U] extends object ? DeepPartial&lt;T[U]&gt; : T[U]&#125;;type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;; 常见工具类型 Pick Exclude Omit Compute Merge Intersection Overwrite Mutable12345678910111213141516171819202122type Exclude&lt;T, U&gt; = T extends U ? never : T;type T = Exclude&lt;1 | 2, 1 | 3&gt; // -&gt; 2 从T中排除出可分配给U的元素type Omit&lt;T, K&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;type Foo = Omit&lt;&#123;name: string, age: number&#125;, 'name'&gt; // -&gt; &#123; age: number &#125; Omit忽略T中的某些属性type Compute&lt;A extends any&gt; = A extends Function ? A : &#123; [K in keyof A]: A[K] &#125; // compute将交叉类型合并type Merge&lt;O1 extends object, O2 extends object&gt; = Compute&lt;O1 &amp; Omit&lt;O2, keyof O1&gt;&gt; // merge将两个对象的属性合并type Intersection&lt;T extends object, U extends object&gt; = Pick&lt;T,Extract&lt;keyof T, keyof U&gt; &amp; Extract&lt;keyof U, keyof T&gt;&gt;; // Intersection取交集type Overwrite&lt; T extends object, U extends object, I = Diff&lt;T, U&gt; &amp; Intersection&lt;U, T&gt;&gt; = Pick&lt;I, keyof I&gt;; // 用U的属性覆盖T的相同属性type Mutable&lt;T&gt; = &#123; -readonly [P in keyof T]: T[P]&#125; // 将T的所有属性的readonly移除 record允许从Union中创建新类型12345678type Car = 'Audi' | 'BMW' | 'MercedesBenz'type CarList = Record&lt;Car, &#123;age: number&#125;&gt;const cars: CarList = &#123; Audi: &#123; age: 119 &#125;, BMW: &#123; age: 113 &#125;, MercedesBenz: &#123; age: 133 &#125;,&#125; 在tsx，如果泛型被当成jsx标签，可以加上 TS的编译原理编译器的组成： Scanner扫描器 Parser解析器 Binder绑定器 Emitter发射器 Checker检查器 处理过程： code + 扫描器 = token流 （词法分析） token流 + 解析器 = AST抽象语法树 （语法分析） AST + 绑定器 = Symbols符号 （语义分析） AST + 符号 + 检查器 = 类型验证 （代码优化） AST + 检查器 + 发射器 = JS代码 （目标代码生成）]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统总结]]></title>
    <url>%2FCS%E5%9F%BA%E7%A1%80%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言几次面试都是因为操作系统完全没看，非常尴尬，看到这些知识，想起了在武大的快乐时光，自己的操作系统课本都送人了，还是得总结一个 OS四大特征 并发：同时发生（并行：不同时，但连续，交替执行） 共享：分互斥共享和同时共享，一段时间内只允许一个进程访问的资源叫做独占资源或者临界资源 异步：类似js的异步 虚拟：空分复用技术（虚拟存储器），时分复用技术（虚拟处理器） 指令是CPU能识别和执行的最基本命令，分为特权指令和非特权指令，内核程序才能执行特权指令，普通程序执行非特权指令。CPU也有内核态和用户态两种状态。 进程定义： 进程是具有独立功能的程序在数据集合上运行的过程，分配资源的基本单位，内存地址空间相互独立 每个进程都有一个进程控制块PCB来描述进程的各种信息，包括PID，UID，状态，优先级，指针，寄存器值等等 进程的基本状态：运行（占有CPU，在CPU上运行），就绪（缺空闲CPU）和阻塞（等待某事件）进程的另外2种2状态：创建态（正在初始化PCB），终止态（撤销PCB，资源回收） 状态转换：运行进入阻塞是主动的（系统调用），阻塞进入就绪是被动的（其他都弄好了，就差CPU了），阻塞不能直接进入运行，就绪也不能直接进入阻塞（因为运行时才能主动请求） 原语：不可被中断的原子操作，使用关中断指令和开中断指令实现，先关再开 进程的通信： 共享存储：互斥的，内存画出一块共享区 管道：半双工，某一时间段只能实现单向传输，双向需要2个管道。字符流形式，管道写满时，write被阻塞，数据都读完时，read被阻塞。如果没写满，就不让读，没空就不让写。读进程只有一个。 消息传递：格式化的消息为单位，通过发送消息/接受消息两个原语进行通信，包括信息头和尾 间接通信：通过中介者信箱来进行通信 同步：某些进程的执行必须先于另一些进程互斥：当某个进程使用某种资源时，其他进程必须等待信号量：解决进程的同步和互斥，由剩余资源和阻塞队列的地址组成生成者消费者问题：生产者的作用是生成一定量数据到缓存区，消费者消耗这些数据，保证生产者不会在满时加入数据，消费者不会在空时消耗数据，用互斥信号量实现互斥访问，同步信号量表示还可以生成多少产品和消耗多少产品 线程定义：进程并发多个事件的能力，基本的CPU执行单位，程序执行流的最小单位，进程可以并发，进程的线程也可以并发，引入线程后，进程只作为除CPU外的系统资源分配单位。线程的切换比进程的切换开销小。 内存内存是计算机硬件与CPU沟通的桥梁，中转站，程序执行前要先放到内存中才能被CPU处理CPU通过内存的存储单元编址来找到执行程序的数据 连续分配：用户进程分配必须是一个连续的内存空间，包括动态分区分配，缺点是会产生内存碎片非连续分配动态分区分配：不会预先划分内存分区，而是动态的建立分区 空闲分区表：分区号，分区大小，起始地址，状态首次适应算法：每次从低地址开始查找，找到第一个满足大小的空闲分区最佳适应算法：从空闲分区表中找到最小的适合分配的分区块来满足需求基本分页存储：把内存空间分成一个个大小相等的分区，每个分区是一个页框，进程的页与内存的页有一一对应关系]]></content>
      <categories>
        <category>CS基础</category>
      </categories>
      <tags>
        <tag>CS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM常见对象和方法总结]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FJS%E5%B8%B8%E8%A7%81API%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言依然是取材于那一次不太满意的面试，setInterval误差问题和requestAnimationFrame，了解的很少，需要学习一下 BOM对象总结浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的自对象。 Window对象方法 alert requestAnimationFrame(callBack)：告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画 cancelAnimationFrame(callBack)：取消之前的动画帧请求 requestIdleCallback：在浏览器空闲期依次调用函数，这样可以把低优先级的任务不会导致动画和交互延迟触发 setImmediate(func)：把需要长时间运行的函数放到回调函数里，在浏览器完成后面的其他语句之后，立即执行这个回调 setInterval(callback)：重复调用一个函数或执行一个代码段，在每次调用之间有一定的事件延迟 clearInterval(intervalID)：取消用setInterval设置的重复定时任务 fetch：用于发起获取资源的请求，返回一个promise对象 postMessage：安全的实现跨源通信 getSelection：返回selection对象，表示用户选择的文本范围或者光标的当前位置 setInterval计时不准确问题：因为其回调函数不是到时执行，这个时间代表的是延迟多少秒，把回调函数放到异步队列，等待主线程空闲再被执行，如果这个callback过于耗时或者有其他耗时任务，会越来越不准确。 当使用setInterval时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中，这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。如果当前事件队列中，存在当前定时器的回调函数，即使到了规定的间隔事件，也不会把这个时间点的回调函数放到事件队列，这样的机制会导致一些间隔被跳过。 解决方法用迭代setTimeout,好处是在前一个定时器执行完之前，不会向队列插入新的定时器代码，确保没有缺失的间隔，而且可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。每次执行setTimeout，创建一个定时器，到达间隔时间时，把定时器回调加入队列，当主线程空闲时，可以执行这个回调函数，因为这个回调函数包含另一个setTimeout，因此可以把这个回调函数放到事件队列，这样执行上一个回调函数的时候，才会把下一个回调函数加入到队列，这样可以避免跳过某些时间点，也可以避免连续执行。因此setTimeout比setInterval稳定 具体写法：计算一个offset，为当前时间减去开始时间，再减去count时间，nextTime为1000减去offset，如果小于0，nexttime为0，setTimeout这个方法，间隔为nextTime。从而计算出下次触发的时间，修正了当前触发的延迟。 12345678function fix()&#123; count++; var offset = new Date().getTime() - (startTime + count * 1000) var nextTime = 1000 - offset if(nextTime &lt; 0) nextTime = 0 setTimeout(fix, nextTime);&#125;setTimeout(fix, 1000) requestAnimationFrame三大好处 把每一帧的dom操作集中，一次重绘或回流中完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率 在隐藏或不可见的元素中，不会回流或重绘，意味着更少的CPU，GPU和内存使用量 浏览器专门为动画提供的api，在运行时浏览器会自动优化方法的调用，如果页面不是激活状态的话，动画会自动暂停，有效节省CPU的开销 Location对象方法 reload：重载来自当前URL的资源，可以接受一个布尔参数，为true表示一定会从服务器拿资源，如果是false或者没有，就可能来自缓存 assign：加载给定URL的内容资源到这个location对象所关联到对象 replace：用给定的URL替换掉当前的资源，与assign方法不同的是，replace替换掉的页面不会出现在history中，不能用回退回到该页面 History对象方法 back：前往上一页，类似于go（-1），也就是页面返回按钮 forward：前往下一页，类似于go（1），也就是页面前进按钮 go：在当前页面的相对位置，从浏览记录加载页面 pushState：按指定的名称和URL把数据push进历史栈 replaceState：更新历史栈的记录 hashChange事件：location.hash触发，前端哈希路由的实现原理 popState事件：pushState或replaceState触发 Navigator对象 onLine属性：返回浏览器是否在线 battery属性：充电信息 connection属性：网络连接信息 geolocation属性：地理位置信息 vibrate（pattern）：调用设备的震动 getUserMedia（）：通过提示获取用户许可，返回一个音频或摄像头的调用 Screen对象 availTop属性：返回屏幕上边有效的距离 availHeight属性：返回屏幕有效的高度 lockOrientation（orientation）：锁定屏幕到某个方向 unlockOrientation：解锁 onorientationchange：屏幕方向改变时触发事件 Document对象 createAttribute（name）：创建并返回一个新的属性节点 createDocumentFragment（）：创建一个新的空白的文档片段 createElement（tagName[,options]）：创建由tagname指定的html元素 querySelector（selectors）：返回文档中匹配指定的选择器组的第一个元素 write（markup）：将一个文本字符串写入由document.open（）打开的一个文档流 writeln（line）：同上，但会换行 append：在parentNode最后一个子节点之后插入一组Node对象或者DOMString对象 getAnimations：返回所运用的css动画，css过渡的元素集合 getElementsBy系列：不解释]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FChrome%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言今天面了一个试，暴露出了很多问题，感觉自己有些知识建立在虚无缥缈之上，没有根基，也不连贯，还是需要多总结和学习。面试官问了一下chrome的进程和线程，自己是凭感觉回答的，天天和chrome打交道，却不太了解有点不行，需要好好的学习一个。 浏览器结构 用户界面 浏览器引擎 渲染引擎（Webkit，Blink，Trident） 网络模块 js引擎（V8） 界面后端 数据存储 多进程架构浏览器Chrome浏览器使用多个进程来隔离不同的网页。因此在Chrome中打开一个网页相当于起了一个进程。原因第一是安全，因为进程间不会共享资源和地址空间，而线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。原因第二是把所有网页都放进一个进程的浏览器面临在健壮性，响应速度，安全性方面的挑战，一个tab崩，浏览器全崩 Chrome的进程打开chrome的任务管理器可以发现，他有很多进程 浏览器进程，占用CPU最多，控制chrome应用程序，包括地址栏，书签，后退和前进按钮等，还有权限管理例如网络请求和文件访问 渲染器进程，控制选项卡内，网站里显示的全部内容 插件进程，chrome的插件，比如flash GPU进程，专门用来处理GPU任务 扩展进程，执行的各种应用插件，例如掘金 标签页进程，每一个标签页也是一个进程 实用进程，比如网络或者声音 Chrome内核（渲染进程）的多线程浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。每个tab网页都有由其独立的渲染引擎实例。 GUI渲染线程，负责渲染html元素，当需要重绘或者回流时执行，js引擎会导致GUI引擎挂起，也就是冻结 js引擎线程，解析js脚本，运行代码 定时触发器线程，因为js是单线程，如果处于阻塞状态会影响计时的准确，因此需要单独的线程进行计时 事件触发线程，事件被触发时，事件线程会把事件添加到待处理事件的队尾，等待js引擎的处理。 异步http请求线程，在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。 js引擎与GUI线程是互斥的：因为js可以操作dom，如果修改的同时渲染界面，那么渲染线程前后获得的元素数据就不一样。所以当js执行时，gui会被挂起，gui更新会被保存到一个队列里，等引擎线程空闲时立即被执行。所以JS执行的时间过长，就会造成页面的渲染不连贯。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式原则 单一职责，一个程序只做一件事，功能过于复杂就取消，每个部分保持独立 开放闭合原则，对扩展开放，对修改封闭，增加需求时，扩展新代码，而非修改已有代码 里氏替换原则，子类能够覆盖父类，父类能出现的地方，子类就能出现 接口隔离原则，保持接口的单一独立，类似单一职责原则，这里更关注接口 依赖倒转原则，面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不关注具体类的实现 单例模式一个类只能构造出唯一的实例比如弹窗，无论点击多少，都只被创建一次实现方法为先判断实例存在与否，不存在创建再返回，存在直接返回，保证一个类只有一个实例 策略模式根据参数的不同可以命中不同的策略两部分组成，策略类封装具体算法，环境类接受客户请求，随后将请求委托给某一个策略类 代理模式代理对象和本体对象具有一致的接口为一个对象提供一个代用品或占位符，以便控制对它的访问比如某一个花销很大的操作，可以先用虚拟代理的方式延迟到需要它的时候才创建，比如图片懒加载 迭代器模式能获取聚合对象的顺序和元素 发布订阅模式PubSub 命令模式不同对象间约定好响应的接口 组合模式组合模式在对象间形成一致对待的树形结构 模版方法模式父类中定好执行顺序 享元模式减少创建实例的个数 职责链模式通过请求第一个条件，会持续执行后续的条件，直到返回结果为止 中介者模式对象和对象之间借助第三方中介者进行通信比如购物车需求，有商品选择表单，颜色选择表单和购买数量表单，都会触发change事件，可以通过中介者来转发处理这个事件 装饰者模式动态的给函数赋能 状态模式每个状态建立一个类，状态改变会产生不同的行为 适配者模式一种数据结构改成另一种数据结构 观察者模式当观察对象发生变化时，自动调用相关函数]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时尚版性能优化]]></title>
    <url>%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言前端性能优化的目的不是追求一味的快，而是优化用户的体验，即使没有实质化的优化，让用户产生性能快的错觉，也是性能优化，用户觉得快，就是真的快，比如加loading。 加载优化（大部分） 首屏loading：html-webpack-plugin，js执行期间加入提示，在文件中插入loading图 预渲染：prerender-spa-plugin，模拟浏览器获取首屏的html结构，在本地模拟浏览器环境，预先执行我们的打包文件，这样通过解析可以获取首屏的html，在正常环境中，可以返回预先解析好的HTML 开启HTTP2：浏览器并发限制一次性6次请求，http2二进制分帧进行通信，多路复用，只需一个tcp通道，请求和响应可以双向通信，头部压缩，只发送差异数据，维护头信息表，以后只发索引号。服务器推送，无需请求，减少多次请求的耗时 开启浏览器缓存：给第三方库设置强缓存，SplitChunksPlugin来做拆包，需要将应用基础库和特定依赖库分离。当chunk在强缓存期但服务器代码变了，需要通知客户端，需要每次引入script脚本的时候去服务器更新，并开启hashchunk，作用是当chunk变化时，hash值也会变，所以不变就命中缓存，变了重新请求 骨架图：antd的骨架屏Skeleton，vue的SkeletonWebpackPlugin，让骨架屏的css分离，直接作为内联style处理到html，提高载入速度 Tree shaking：通过程序流分析找出你代码中无用的代码并剔除，webpack4自带，坑Babel转译，因为需要es5的module，需要手动关闭commonjs；坑2第三方库不可控，因为有些只有es5版本 路由分割优化：只加载当前页面的代码，比如component: ()=&gt; import(‘@components/login’), 这样登陆页会被单独打包 组件懒加载：在页面的加载中只渲染部分必须的组件,而其余的组件可以按需加载。基于lazy+suspense，比如把echart的图进行懒加载 组件预加载：在用户的鼠标还处于hover状态的时候就开始触发图表资源的加载,通常情况下当用户点击结束之后,加载也基本完成,这个时候图表会很顺利地渲染出来,不会出现延迟 keep alive：vue中，在页面跳转后不销毁组件，先保存组件对应的实例到内存，当页面需要再次渲染时，可以利用这个缓存。但实例过多容易出现内存泄漏，注意调用deactivated销毁。react官网宣布不会加类似api，但可以用redux状态缓存（不推荐），或者React Keep Alive这个库 图片懒加载：页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域后再去加载。可见区域监听滚动事件 资源压缩：服务端启动gzip CDN：静态资源走CDN，使用户就近获取内容，降低访问时延，减轻了源站的负载。静态资源不需要cookie，把静态资源和主页面置于不同的域名下，可以避免请求中携带不必要的cookie（同一个域名下的所有请求，都会携带一个相同的cookie，设置不当就会很大） 雪碧图，icon：这个不解释 执行优化（小部分）动画一般是性能的重灾区，需要大量的计算和渲染，主要有三种方式： Canvas CSS3 Dom 动画优化方案： Dom优化之Dom+js：容易引起回流和重绘，优化就是不用Dom+js做动画 CSS3优化之动画放在同一图层（合成层）：图层的概念，浏览器渲染页面，会把页面分成很多图层，对每个图层的节点计算样式，生成图形和位置，再把节点绘制到图层位图中，图层作为纹理上传至GPU，图层重组生成屏幕图像。将动画放在一个独立图层,这样可以避免动画效果影响其他渲染层的元素。比如iframe，video，3D或2D canvas，flash，3D transform，backface-visibility 为 hidden等 CSS3优化之避免重绘和回流：多使用transform和opacity来实现动画效果 CSS3优化之GPU加速：浏览器把一部分渲染任务丢给GPU。这部分css元素会提升到合成层，使得当页面上只有这个元素发生变换(transform)的时候其余元素不需要重新渲染。opacity，translate，rotate和scale会触发硬件加速，opacity号称性能最好的属性之一。 CSS3优化之will change：will-change，最好的方式，设置为opacity，transform或上下左右，允许我们提前告知浏览器可能会对元素进行哪些操作，让浏览器去优化并提前处理那些潜在的比较消耗性能的操作比如在动画开始之前，提前处理元素的动画行为。过多使用会占用计算机资源，且需要留足够时间，变更失效需要移除。 Canvas优化之requestAnimationFrame：setInterval定时完成动画不可靠，容易掉帧。requestAnimationFrame性能好，将所有动画放到一个浏览器重绘周期里去做，这样可以保存cpu循环次数，提高性能。开销更小，浏览器专门为动画提供的效果，运行时浏览器会自动优化方法的调用，如果页面不是激活状态，动画会暂停，节省了cpu开销 Canvas优化之离屏canvas：离屏canvas当成一个缓存区。把需要重复绘制的画面数据进行缓存起来，减少调用 canvas的 API的消耗。 Canvas优化之避免浮点运算：浮点数可能会使元素抖动或者抗锯齿失真 Canvas优化之减少调用Canvas API：通过适量js原生计算减少canvas API的调用，粒子效果少用圆，最好用方形 Web woker：分担主线程的压力 大量数据性能优化方案： 虚拟列表：只渲染可视区域的数据，startIndex，endIndex，计算startOffset webwork：完全和UI线程（主线程）并行的执行js代码，从而不会阻塞UI，它和主线程是通过 onmessage 和 postMessage 接口进行通信的。当主线程在处理界面事件时，worker 可以在后台运行，帮你处理大量的数据计算，当计算完成，将计算结果返回给主线程，由主线程更新 DOM 元素]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Fiber初探]]></title>
    <url>%2FReact%2F%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[scheduler fiber reconcifer的过程，决定什么时候做什么 stack reconcifer是一气呵成的，但需要考虑一些情况，不是所有的state更新都要实时显示，不同state更新的优先级应该不同，高优先级可以打断低优先级 在fiber reconcifer，每次做一个小任务，再回主线程看看有没有更高优先级的任务需要处理，有的话优先执行，没有的话继续 假如我们安排100ms来更新视图和虚拟dom，40ms给浏览器做其他事情，如果我们不需要100ms来更新或者浏览器需要超过40ms，就需要进行时间的调度，浏览器有一些api可供选择 requestAnimationFrame：帧数控制调用，做动画 requestIdleCallback：闲时调用 web worker：多线程调用 intersectionObserver：进入可视区调用，比如虚拟列表 客户端线程执行任务以帧为单位，30-60不会影响用户体验，每两个帧之间主线程会有空闲，这时候requestIdleCallback可以调用回调，执行任务。 requestIdleCallback来处理低优先级任务，提高deadline，任务执行限制时间来切分任务，避免长时间执行，导致阻塞UI渲染而掉帧 requestAnimationFrame处理高优先级任务 stack reconciler 工作流程类似函数调用，从父节点进行遍历，找出不同，才能找出需要修改的信息，传递给renderer，进行渲染，再显示在屏幕上 这个过程主线程被react占住，大型项目中会出现屏幕卡顿 代码中有元素的创建或者更新，react会根据这些元素创建虚拟dom，diff算法，更新真实dom，dom的更新是同步的，也就意味着在diff过程中，发现不同的instance，立刻执行dom操作 fiber reconciler 操作可以分成小部分，可以被中断 fiber有四个属性，stateNode管理instance自身的特性，通过child（第一个孩子）和sibling（右边的兄弟）表示下一个工作单位，return（父节点）表示返回结果需要合并的目标。整个结构是个链表树，每个fiber单位执行完，会查看是否拥有主线程时间片，有的话继续，没有的话先处理高优先级事务 页面渲染，react生成一个fiber tree，类似虚拟dom树，同时维护一个workInProgressTree，用于计算更新 fiber工作流程 组件更新，更新的state加入当前组件的update queue，交给scheduler 使用requestIdleCallback api，浏览器不支持用pollyfill，scheduler根据主线程的情况处理这次update reconciliation过程得到时间片，进入work loop（让react在计算状态和等待状态间切换） 每个loop需要追踪下一个工作单元和当前还能占据主线程的时间 第一个loop，下一个待处理单元为根节点，因为根节点对应的update队列为空，直接将根节点复制到workInProgrssTree 再复制其子节点，子节点向其父节点返回，标志父节点处理结束，此时react检查时间片是否用完，没有用完处理下一个 子节点包含更新，react会调用setState的updater函数获得最新state值，需要传入一个函数 12setState(&#123;&#125;, callback); // stack concilersetState(() =&gt; &#123; return &#123;&#125; &#125;, callback); // fiber conciler 得到最新的state，react会更新props和state，调用render，得到elements，然后决定是否可以重用，需要更新的节点会打上标签 如果此时用户点击放大字体的按钮，操作不能立即实现，因为时间片被react占住。处理完一个节点看时间够不够用。 通过shouldComponentUpdate钩子可以根据传入的props判断其是否需要改变，返回ture表示要，打上标签 react会维护一个effect list列表，记录所有标签元素 当所有节点标记完成，react将workInProgressTree标记为pendingCommit，可以进入commit阶段 此时还是检查时间够不够用，够时间的话根据effect list更新Dom 此时workInProgress和DOM保持一致，交换current和workInProgress两个指针 commit完执行componentDidMount函数 fiber优先级策略核心：低优先级会被高优先级操作打断，并让主线程执行高优先级的更新，当主线程重新分配给低优先级的操作时，会重新开始12345678module.exports = &#123; NoWork: 0, // No work is pending. SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects. AnimationPriority: 2, // Needs to complete before the next frame. HighPriority: 3, // Interaction that needs to complete pretty soon to feel responsive. LowPriority: 4, // Data fetching, or result from updating stores. OffscreenPriority: 5, // Won't be visible but do the work in case it becomes visible.&#125;;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useEffect小试]]></title>
    <url>%2FReact%2FReact-Hooks%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前序实习了3天，感受到了互联网公司的快节奏React hooks，TS，Sass是基础，而自己又不太熟，需要补补课React hooks之前看了一下官方文档，感觉非常清晰，然鹅做起项目来，还是有点不大理解，需要捋一捋 useEffectreact只会在浏览器绘制之后运行effectsuseEffect函数在每一次渲染中都不同，对应的state值也只属于当前那次渲染。一个function对应多次渲染，每一次渲染中useEffect和state都是不同且独立的，每个effect函数看到的props和state都是来自他属于的那次渲染 一次完整的渲染过程，以官网count为例子 组件给react需要渲染的内容，此时count为0，并告诉react渲染之后调用effect函数 react拿到组件渲染内容，更新UI，告诉DOM进行修改 浏览器绘制后告诉react，react运行effect 然后count为1，组件给react count为1时的渲染内容，重复进行 和componentDidUpdate相比，componentDidUpdate的state会指向最新的state，而hooks会指向某次特定渲染的值，这也是闭包的一个应用。如果想在effec的回调中拿到最新的值而不是每次渲染的值，可以用refs effect清理 react渲染id为1的UI 浏览器绘制，我们看到id为1的UI react清除id为0的effect react运行id为1的effect，id变成2上一次的effect会在重新渲染后，被清除，effect的清除并不会读取到最新的props。所以react能做到在绘制后立即处理effect 依赖数组deps因为react无法区分effects之间的不同，只能依靠deps如果两次渲染，deps一样，react会跳过这次effect，也就是只有deps改变，effect才会生效如果deps为空，表示只有第一次渲染会执行effect 依赖撒谎依赖是我们给react的暗示，告诉它effect里需要使用的渲染的值，如果effect使用了count，但依赖数组里没有，会出大问题。比如设置定时器，定时器调用了state但没有在deps里面标明，这样effect不会重复调用，每一次setCount里count都是常数123456789101112function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); // setCount(c =&gt; c + 1); 正确的姿势 &#125;, 1000); return () =&gt; clearInterval(id); &#125;, []); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; useEffect发请求12345678910111213useEffect(() =&gt; &#123; async function fetchData()&#123; const result = await axios() &#125; fetchData()&#125;, [])async function fetchData()&#123; const result = await axios()&#125;useEffect(() =&gt; &#123; fetchData()&#125;, []) 请求函数写在useEffect里面容易出现问题，比如如果async函数里面有一个state，UserID，我们需要在deps里面加入，但由于代码量比较大，我们非常可能忘记加上这个deps，然而如果我们把async函数写在useEffect里面，就很直观，程序员可以意识到要加这个间接依赖 如果几个effect调用了同一个函数，可以把函数放在整个组件外面，或者用callback钩子12345678910111213141516171819202122232425function getFetchUrl(query) &#123; return 'https://hn.algolia.com/api/v1/search?query=' + query;&#125;function SearchResults() &#123; useEffect(() =&gt; &#123; const url = getFetchUrl('react'); &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl('redux'); &#125;, []);&#125;function SearchResults() &#123; const getFetchUrl = useCallback((query) =&gt; &#123; return 'https://hn.algolia.com/api/v1/search?query=' + query; &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl('react'); &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl('redux'); &#125;, [getFetchUrl]); &#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在NTU毕业前夕]]></title>
    <url>%2Funcategorized%2F%E5%86%99%E5%9C%A8NTU%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%2F</url>
    <content type="text"><![CDATA[今天是2020年5月2号，算是一个里程碑式的节点，上传了NTU最后一门课text mining的作业，终于可以专心集中的搞一个领域了，有点小开心。博客今天也重新开张了，是时候规划总结一波了 算法学习今天是刷leetcode的108天，目前leetcode刷了207道题，基本都是python写的，力扣刷了140道，基本都是js写的，ScriptOj刷了50道题。本科算法基础有点差，现在刷了一些题感觉还是很有效果的，之后打算继续刷。定个小目标，拿到ntu毕业证之前： leetcode hot 100用js刷完做好笔记 ScriptOj刷完做好笔记 总结常见算法题型，回溯，动态规划，双指针，滑动窗口，树，单调栈，二分法，矩阵和一些小众算法比如摩尔投票等等 力扣有竞赛就打，打tmd 一天1道算法题，多了刷不动 前端学习今天是学习前端的103天，通过实习的项目和这两个月面试的磨练，前端的基础已经搭起来了，接下来主要就是实践。定个小目标，拿到ntu毕业证之前： 把之前面试准备的知识点总结到github 多逛逛掘金和大佬们的博客，提高一下姿势水平 在快手好好搬砖，争取拿个return offer 技术栈提高一下广度，深度现在还搞不定，flutter，react全家桶，typescript，weex，nodejs学一学 一天3道面经题总结，面经永远是最好的学习方式 博客今天是写博客的第一天，1年半没写了，现在要开始笔根不辍起来，定个计划 一周出一篇博客，一个知识点，内容随意，先养成一个习惯 书籍趁着还没正式996，先看点不看会被同行看不起的书，提高一个，一天一章，按顺序看，今年肝完（先立flag，看不完明年看） JS高程，现在看了四章，发现面经好多都在这个上面，哭了 深入理解ES6 Javascript设计模式 JavaScript异步编程 高性能javascript 学习javascript数据结构与算法 你不知道的javascript JavaScript权威指南 JavaScript编程精解 JavaScript语言精粹]]></content>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
</search>
