<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TS总结（一）]]></title>
    <url>%2FTypeScript%2FTS%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言codereview被ts搞得非常痛苦，需要好好学习一个 TS是静态类型化的js超集，静态性使其牛逼语言在编译时报错是静态语言，运行时报错时动态语言TS是静态弱类型语言，不是强类型，因为要兼容js，不限制js的隐式类型转换 使用TS的优点： 可以避免低级错误，在编写时就能发现 减少多人合作的成本，适合大项目 良好的代码提示 类型TS的原始类型： boolean number string null undefined symbol void bigint与js类型的区别，多了void和bigint，且都是小写开头 TS的其他常见类型： any：不到万不得已，不要用，和js没有多少区别 unknown：any的安全类型，unknown类型值操作之前，要进行检查，而any不用。虽然可以是任何类型，但unknown不能被进行任何操作比如对象取值等等。可以用来缩小类型范围 never：永不存在的值的类型，任何类型的子类型，可以赋值给任何类型，但没有类型可以赋值给never（除了自己），也没有never的子类型。用于定义永远是空的数组，永远不会有返回值的函数，比如抛出异常。 数组：范型定义（const list: Array = [1,2,3])，元素类型加[]，(const list: number[] = [1,2,3]) 元组：严格版数组，但是元素的类型可以不同，let x: [string, number] = [‘hello’, 12]，元组可以push添加元素，但不能访问 object：普通对象，数组，枚举，元组都是object类型 枚举：声明一组命名的常数 数字枚举从0开始，依次加1，累加效应 字符串枚举可以用方括号取值（需要加双引号）也可以用点号取值 异构枚举，前两者混合，也可以但少见 正反向映射，可以用枚举名字取枚举值，也能用枚举值取枚举名字，原理是Direction[Direction[“Up”] = 10] = “Up”，所以up或者10都能取到 常量枚举，Up = ‘Up’，好处在于编译成js之后，直接省略了枚举，是性能提升的一个方案 字面量类型的情况，枚举的成员和枚举值可以当成类型使用 接口interface只能用于定义对象类型可选属性：后面加?，可能是undefined只读属性：前面加readonly，修改会给出警告可索引类型：可以用来表示{北京：1}12345678910interface Phone &#123; [name: string]: string&#125;interface User &#123; name: string // 普通 age?: number // 可选属性 readonly isMale: boolean //只读属性 say: () =&gt; string // 函数属性 phone: Phone // &#125; extends可以继承接口，在父接口的基础上，加上新的属性 类和函数 abstract抽象类，无法实例化，被继承 public都能访问，private只能类内访问，protected只能类内和子类访问 类也可以作为接口 函数可以重载 泛型定义：在静态编写时不知道传入的参数到底是什么类型，只有在运行时传入参数才能确定，所以我们需要变量代表传入的类型，再返回这个变量，只用于表示类型而不表示值 类型断言12345interface Person &#123; name: string; age: number&#125;const person = &#123;&#125; as Person 双重断言，先断成any再断成自己想要的 类型守卫1234567891011function a(arg: person | animal)&#123; if(arg instanceof person)&#123; xxx &#125; if('age' in arg)&#123; xxx &#125; if(arg.kind === 'foo')&#123; xxx &#125;&#125; 联合类型：中间用｜隔开，表示这些类型都可以 交叉类型：const result = {} 类型别名：type some = boolean | string React实战 React.FC可以无需声明children属性的类型，会为props自动加上 input的onchange，e的类型为React.ChangeEvent，就可以用e.target.value了 表单的submit，e的类型为React.FormEvent 当我们在组件中输入事件对应的名称时，会有相关的定义提示，我们只要用这个提示中的类型就可以了 索引类型查询keyof可以作用于泛型，来获取泛型所有的属性名构成联合属性keyof可以取到索引类型的属性名，但还要获取属性值的类型，所以需要索引访问符，T[K] 12345678910111213class Images &#123; public src: string = 'https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png' public alt: string = '谷歌' public width: number = 500&#125;type propsNames = keyof Images // src | alt | widthtype propsType = Images[propsNames] // string | numberfunction pick&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123; return names.map(n =&gt; o[n]);&#125;const res = pick(user, ['token', 'id', ]) pick的例子，需要一个泛型T表示传入参数o的类型，因为编写时无法确定o是什么类型，第二个参数names表示数组的成员必须由参数o的属性名称构成，所以用keyof代表o类型的属性名的联合类型，所以用K约束到keyof T。返回值T[K]取到对应属性值的类型，T[K][]表示返回值的类型 映射类型把接口成员都变成可选 一个一个在成员前加? 映射法 语法：[K in Keys]K对应每个属性名的类型，Keys表示一组属性名的类型，所以[K in keyof T]表示属性的类型，T[K]表示属性值的类型结果：type partial = { [K in keyof T]?: T[K] }]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统总结]]></title>
    <url>%2FCS%E5%9F%BA%E7%A1%80%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言几次面试都是因为操作系统完全没看，非常尴尬，看到这些知识，想起了在武大的快乐时光，自己的操作系统课本都送人了，还是得总结一个 OS四大特征 并发：同时发生（并行：不同时，但连续，交替执行） 共享：分互斥共享和同时共享，一段时间内只允许一个进程访问的资源叫做独占资源或者临界资源 异步：类似js的异步 虚拟：空分复用技术（虚拟存储器），时分复用技术（虚拟处理器） 指令是CPU能识别和执行的最基本命令，分为特权指令和非特权指令，内核程序才能执行特权指令，普通程序执行非特权指令。CPU也有内核态和用户态两种状态。]]></content>
      <categories>
        <category>CS基础</category>
      </categories>
      <tags>
        <tag>CS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM常见对象和方法总结]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FJS%E5%B8%B8%E8%A7%81API%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言依然是取材于那一次不太满意的面试，setInterval误差问题和requestAnimationFrame，了解的很少，需要学习一下 BOM对象总结浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的自对象。 Window对象方法 alert requestAnimationFrame(callBack)：告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画 cancelAnimationFrame(callBack)：取消之前的动画帧请求 requestIdleCallback：在浏览器空闲期依次调用函数，这样可以把低优先级的任务不会导致动画和交互延迟触发 setImmediate(func)：把需要长时间运行的函数放到回调函数里，在浏览器完成后面的其他语句之后，立即执行这个回调 setInterval(callback)：重复调用一个函数或执行一个代码段，在每次调用之间有一定的事件延迟 clearInterval(intervalID)：取消用setInterval设置的重复定时任务 fetch：用于发起获取资源的请求，返回一个promise对象 postMessage：安全的实现跨源通信 getSelection：返回selection对象，表示用户选择的文本范围或者光标的当前位置 setInterval计时不准确问题：因为其回调函数不是到时执行，这个时间代表的是延迟多少秒，把回调函数放到异步队列，等待主线程空闲再被执行，如果这个callback过于耗时或者有其他耗时任务，会越来越不准确。 当使用setInterval时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中，这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。如果当前事件队列中，存在当前定时器的回调函数，即使到了规定的间隔事件，也不会把这个时间点的回调函数放到事件队列，这样的机制会导致一些间隔被跳过。 解决方法用迭代setTimeout,好处是在前一个定时器执行完之前，不会向队列插入新的定时器代码，确保没有缺失的间隔，而且可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。每次执行setTimeout，创建一个定时器，到达间隔时间时，把定时器回调加入队列，当主线程空闲时，可以执行这个回调函数，因为这个回调函数包含另一个setTimeout，因此可以把这个回调函数放到事件队列，这样执行上一个回调函数的时候，才会把下一个回调函数加入到队列，这样可以避免跳过某些时间点，也可以避免连续执行。因此setTimeout比setInterval稳定 具体写法：计算一个offset，为当前时间减去开始时间，再减去count时间，nextTime为1000减去offset，如果小于0，nexttime为0，setTimeout这个方法，间隔为nextTime。从而计算出下次触发的时间，修正了当前触发的延迟。 12345678function fix()&#123; count++; var offset = new Date().getTime() - (startTime + count * 1000) var nextTime = 1000 - offset if(nextTime &lt; 0) nextTime = 0 setTimeout(fix, nextTime);&#125;setTimeout(fix, 1000) requestAnimationFrame三大好处 把每一帧的dom操作集中，一次重绘或回流中完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率 在隐藏或不可见的元素中，不会回流或重绘，意味着更少的CPU，GPU和内存使用量 浏览器专门为动画提供的api，在运行时浏览器会自动优化方法的调用，如果页面不是激活状态的话，动画会自动暂停，有效节省CPU的开销 Location对象方法 reload：重载来自当前URL的资源，可以接受一个布尔参数，为true表示一定会从服务器拿资源，如果是false或者没有，就可能来自缓存 assign：加载给定URL的内容资源到这个location对象所关联到对象 replace：用给定的URL替换掉当前的资源，与assign方法不同的是，replace替换掉的页面不会出现在history中，不能用回退回到该页面 History对象方法 back：前往上一页，类似于go（-1），也就是页面返回按钮 forward：前往下一页，类似于go（1），也就是页面前进按钮 go：在当前页面的相对位置，从浏览记录加载页面 pushState：按指定的名称和URL把数据push进历史栈 replaceState：更新历史栈的记录 hashChange事件：location.hash触发，前端哈希路由的实现原理 popState事件：pushState或replaceState触发 Navigator对象 onLine属性：返回浏览器是否在线 battery属性：充电信息 connection属性：网络连接信息 geolocation属性：地理位置信息 vibrate（pattern）：调用设备的震动 getUserMedia（）：通过提示获取用户许可，返回一个音频或摄像头的调用 Screen对象 availTop属性：返回屏幕上边有效的距离 availHeight属性：返回屏幕有效的高度 lockOrientation（orientation）：锁定屏幕到某个方向 unlockOrientation：解锁 onorientationchange：屏幕方向改变时触发事件 Document对象 createAttribute（name）：创建并返回一个新的属性节点 createDocumentFragment（）：创建一个新的空白的文档片段 createElement（tagName[,options]）：创建由tagname指定的html元素 querySelector（selectors）：返回文档中匹配指定的选择器组的第一个元素 write（markup）：将一个文本字符串写入由document.open（）打开的一个文档流 writeln（line）：同上，但会换行 append：在parentNode最后一个子节点之后插入一组Node对象或者DOMString对象 getAnimations：返回所运用的css动画，css过渡的元素集合 getElementsBy系列：不解释]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FChrome%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言今天面了一个试，暴露出了很多问题，感觉自己有些知识建立在虚无缥缈之上，没有根基，也不连贯，还是需要多总结和学习。面试官问了一下chrome的进程和线程，自己是凭感觉回答的，天天和chrome打交道，却不太了解有点不行，需要好好的学习一个。 浏览器结构 用户界面 浏览器引擎 渲染引擎（Webkit，Blink，Trident） 网络模块 js引擎（V8） 界面后端 数据存储 多进程架构浏览器Chrome浏览器使用多个进程来隔离不同的网页。因此在Chrome中打开一个网页相当于起了一个进程。原因第一是安全，因为进程间不会共享资源和地址空间，而线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。原因第二是把所有网页都放进一个进程的浏览器面临在健壮性，响应速度，安全性方面的挑战，一个tab崩，浏览器全崩 Chrome的进程打开chrome的任务管理器可以发现，他有很多进程 浏览器进程，占用CPU最多，控制chrome应用程序，包括地址栏，书签，后退和前进按钮等，还有权限管理例如网络请求和文件访问 渲染器进程，控制选项卡内，网站里显示的全部内容 插件进程，chrome的插件，比如flash GPU进程，专门用来处理GPU任务 扩展进程，执行的各种应用插件，例如掘金 标签页进程，每一个标签页也是一个进程 实用进程，比如网络或者声音 Chrome内核（渲染进程）的多线程浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。每个tab网页都有由其独立的渲染引擎实例。 GUI渲染线程，负责渲染html元素，当需要重绘或者回流时执行，js引擎会导致GUI引擎挂起，也就是冻结 js引擎线程，解析js脚本，运行代码 定时触发器线程，因为js是单线程，如果处于阻塞状态会影响计时的准确，因此需要单独的线程进行计时 事件触发线程，事件被触发时，事件线程会把事件添加到待处理事件的队尾，等待js引擎的处理。 异步http请求线程，在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。 js引擎与GUI线程是互斥的：因为js可以操作dom，如果修改的同时渲染界面，那么渲染线程前后获得的元素数据就不一样。所以当js执行时，gui会被挂起，gui更新会被保存到一个队列里，等引擎线程空闲时立即被执行。所以JS执行的时间过长，就会造成页面的渲染不连贯。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式原则 单一职责，一个程序只做一件事，功能过于复杂就取消，每个部分保持独立 开放闭合原则，对扩展开放，对修改封闭，增加需求时，扩展新代码，而非修改已有代码 里氏替换原则，子类能够覆盖父类，父类能出现的地方，子类就能出现 接口隔离原则，保持接口的单一独立，类似单一职责原则，这里更关注接口 依赖倒转原则，面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不关注具体类的实现 单例模式一个类只能构造出唯一的实例比如弹窗，无论点击多少，都只被创建一次实现方法为先判断实例存在与否，不存在创建再返回，存在直接返回，保证一个类只有一个实例 策略模式根据参数的不同可以命中不同的策略两部分组成，策略类封装具体算法，环境类接受客户请求，随后将请求委托给某一个策略类 代理模式代理对象和本体对象具有一致的接口为一个对象提供一个代用品或占位符，以便控制对它的访问比如某一个花销很大的操作，可以先用虚拟代理的方式延迟到需要它的时候才创建，比如图片懒加载 迭代器模式能获取聚合对象的顺序和元素 发布订阅模式PubSub 命令模式不同对象间约定好响应的接口 组合模式组合模式在对象间形成一致对待的树形结构 模版方法模式父类中定好执行顺序 享元模式减少创建实例的个数 职责链模式通过请求第一个条件，会持续执行后续的条件，直到返回结果为止 中介者模式对象和对象之间借助第三方中介者进行通信比如购物车需求，有商品选择表单，颜色选择表单和购买数量表单，都会触发change事件，可以通过中介者来转发处理这个事件 装饰者模式动态的给函数赋能 状态模式每个状态建立一个类，状态改变会产生不同的行为 适配者模式一种数据结构改成另一种数据结构 观察者模式当观察对象发生变化时，自动调用相关函数]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时尚版性能优化]]></title>
    <url>%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言前端性能优化的目的不是追求一味的快，而是优化用户的体验，即使没有实质化的优化，让用户产生性能快的错觉，也是性能优化，用户觉得快，就是真的快，比如加loading。 加载优化（大部分） 首屏loading：html-webpack-plugin，js执行期间加入提示，在文件中插入loading图 预渲染：prerender-spa-plugin，模拟浏览器获取首屏的html结构，在本地模拟浏览器环境，预先执行我们的打包文件，这样通过解析可以获取首屏的html，在正常环境中，可以返回预先解析好的HTML 开启HTTP2：浏览器并发限制一次性6次请求，http2二进制分帧进行通信，多路复用，只需一个tcp通道，请求和响应可以双向通信，头部压缩，只发送差异数据，维护头信息表，以后只发索引号。服务器推送，无需请求，减少多次请求的耗时 开启浏览器缓存：给第三方库设置强缓存，SplitChunksPlugin来做拆包，需要将应用基础库和特定依赖库分离。当chunk在强缓存期但服务器代码变了，需要通知客户端，需要每次引入script脚本的时候去服务器更新，并开启hashchunk，作用是当chunk变化时，hash值也会变，所以不变就命中缓存，变了重新请求 骨架图：antd的骨架屏Skeleton，vue的SkeletonWebpackPlugin，让骨架屏的css分离，直接作为内联style处理到html，提高载入速度 Tree shaking：通过程序流分析找出你代码中无用的代码并剔除，webpack4自带，坑Babel转译，因为需要es5的module，需要手动关闭commonjs；坑2第三方库不可控，因为有些只有es5版本 路由分割优化：只加载当前页面的代码，比如component: ()=&gt; import(‘@components/login’), 这样登陆页会被单独打包 组件懒加载：在页面的加载中只渲染部分必须的组件,而其余的组件可以按需加载。基于lazy+suspense，比如把echart的图进行懒加载 组件预加载：在用户的鼠标还处于hover状态的时候就开始触发图表资源的加载,通常情况下当用户点击结束之后,加载也基本完成,这个时候图表会很顺利地渲染出来,不会出现延迟 keep alive：vue中，在页面跳转后不销毁组件，先保存组件对应的实例到内存，当页面需要再次渲染时，可以利用这个缓存。但实例过多容易出现内存泄漏，注意调用deactivated销毁。react官网宣布不会加类似api，但可以用redux状态缓存（不推荐），或者React Keep Alive这个库 图片懒加载：页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域后再去加载。可见区域监听滚动事件 资源压缩：服务端启动gzip CDN：静态资源走CDN，使用户就近获取内容，降低访问时延，减轻了源站的负载。静态资源不需要cookie，把静态资源和主页面置于不同的域名下，可以避免请求中携带不必要的cookie（同一个域名下的所有请求，都会携带一个相同的cookie，设置不当就会很大） 雪碧图，icon：这个不解释 执行优化（小部分）动画一般是性能的重灾区，需要大量的计算和渲染，主要有三种方式： Canvas CSS3 Dom 动画优化方案： Dom优化之Dom+js：容易引起回流和重绘，优化就是不用Dom+js做动画 CSS3优化之动画放在同一图层（合成层）：图层的概念，浏览器渲染页面，会把页面分成很多图层，对每个图层的节点计算样式，生成图形和位置，再把节点绘制到图层位图中，图层作为纹理上传至GPU，图层重组生成屏幕图像。将动画放在一个独立图层,这样可以避免动画效果影响其他渲染层的元素。比如iframe，video，3D或2D canvas，flash，3D transform，backface-visibility 为 hidden等 CSS3优化之避免重绘和回流：多使用transform和opacity来实现动画效果 CSS3优化之GPU加速：浏览器把一部分渲染任务丢给GPU。这部分css元素会提升到合成层，使得当页面上只有这个元素发生变换(transform)的时候其余元素不需要重新渲染。opacity，translate，rotate和scale会触发硬件加速，opacity号称性能最好的属性之一。 CSS3优化之will change：will-change，最好的方式，设置为opacity，transform或上下左右，允许我们提前告知浏览器可能会对元素进行哪些操作，让浏览器去优化并提前处理那些潜在的比较消耗性能的操作比如在动画开始之前，提前处理元素的动画行为。过多使用会占用计算机资源，且需要留足够时间，变更失效需要移除。 Canvas优化之requestAnimationFrame：setInterval定时完成动画不可靠，容易掉帧。requestAnimationFrame性能好，将所有动画放到一个浏览器重绘周期里去做，这样可以保存cpu循环次数，提高性能。开销更小，浏览器专门为动画提供的效果，运行时浏览器会自动优化方法的调用，如果页面不是激活状态，动画会暂停，节省了cpu开销 Canvas优化之离屏canvas：离屏canvas当成一个缓存区。把需要重复绘制的画面数据进行缓存起来，减少调用 canvas的 API的消耗。 Canvas优化之避免浮点运算：浮点数可能会使元素抖动或者抗锯齿失真 Canvas优化之减少调用Canvas API：通过适量js原生计算减少canvas API的调用，粒子效果少用圆，最好用方形 Web woker：分担主线程的压力 大量数据性能优化方案： 虚拟列表：只渲染可视区域的数据，startIndex，endIndex，计算startOffset webwork：完全和UI线程（主线程）并行的执行js代码，从而不会阻塞UI，它和主线程是通过 onmessage 和 postMessage 接口进行通信的。当主线程在处理界面事件时，worker 可以在后台运行，帮你处理大量的数据计算，当计算完成，将计算结果返回给主线程，由主线程更新 DOM 元素]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Fiber初探]]></title>
    <url>%2FReact%2F%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[scheduler fiber reconcifer的过程，决定什么时候做什么 stack reconcifer是一气呵成的，但需要考虑一些情况，不是所有的state更新都要实时显示，不同state更新的优先级应该不同，高优先级可以打断低优先级 在fiber reconcifer，每次做一个小任务，再回主线程看看有没有更高优先级的任务需要处理，有的话优先执行，没有的话继续 假如我们安排100ms来更新视图和虚拟dom，40ms给浏览器做其他事情，如果我们不需要100ms来更新或者浏览器需要超过40ms，就需要进行时间的调度，浏览器有一些api可供选择 requestAnimationFrame：帧数控制调用，做动画 requestIdleCallback：闲时调用 web worker：多线程调用 intersectionObserver：进入可视区调用，比如虚拟列表 客户端线程执行任务以帧为单位，30-60不会影响用户体验，每两个帧之间主线程会有空闲，这时候requestIdleCallback可以调用回调，执行任务。 requestIdleCallback来处理低优先级任务，提高deadline，任务执行限制时间来切分任务，避免长时间执行，导致阻塞UI渲染而掉帧 requestAnimationFrame处理高优先级任务 stack reconciler 工作流程类似函数调用，从父节点进行遍历，找出不同，才能找出需要修改的信息，传递给renderer，进行渲染，再显示在屏幕上 这个过程主线程被react占住，大型项目中会出现屏幕卡顿 代码中有元素的创建或者更新，react会根据这些元素创建虚拟dom，diff算法，更新真实dom，dom的更新是同步的，也就意味着在diff过程中，发现不同的instance，立刻执行dom操作 fiber reconciler 操作可以分成小部分，可以被中断 fiber有四个属性，stateNode管理instance自身的特性，通过child（第一个孩子）和sibling（右边的兄弟）表示下一个工作单位，return（父节点）表示返回结果需要合并的目标。整个结构是个链表树，每个fiber单位执行完，会查看是否拥有主线程时间片，有的话继续，没有的话先处理高优先级事务 页面渲染，react生成一个fiber tree，类似虚拟dom树，同时维护一个workInProgressTree，用于计算更新 fiber工作流程 组件更新，更新的state加入当前组件的update queue，交给scheduler 使用requestIdleCallback api，浏览器不支持用pollyfill，scheduler根据主线程的情况处理这次update reconciliation过程得到时间片，进入work loop（让react在计算状态和等待状态间切换） 每个loop需要追踪下一个工作单元和当前还能占据主线程的时间 第一个loop，下一个待处理单元为根节点，因为根节点对应的update队列为空，直接将根节点复制到workInProgrssTree 再复制其子节点，子节点向其父节点返回，标志父节点处理结束，此时react检查时间片是否用完，没有用完处理下一个 子节点包含更新，react会调用setState的updater函数获得最新state值，需要传入一个函数 12setState(&#123;&#125;, callback); // stack concilersetState(() =&gt; &#123; return &#123;&#125; &#125;, callback); // fiber conciler 得到最新的state，react会更新props和state，调用render，得到elements，然后决定是否可以重用，需要更新的节点会打上标签 如果此时用户点击放大字体的按钮，操作不能立即实现，因为时间片被react占住。处理完一个节点看时间够不够用。 通过shouldComponentUpdate钩子可以根据传入的props判断其是否需要改变，返回ture表示要，打上标签 react会维护一个effect list列表，记录所有标签元素 当所有节点标记完成，react将workInProgressTree标记为pendingCommit，可以进入commit阶段 此时还是检查时间够不够用，够时间的话根据effect list更新Dom 此时workInProgress和DOM保持一致，交换current和workInProgress两个指针 commit完执行componentDidMount函数 fiber优先级策略核心：低优先级会被高优先级操作打断，并让主线程执行高优先级的更新，当主线程重新分配给低优先级的操作时，会重新开始12345678module.exports = &#123; NoWork: 0, // No work is pending. SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects. AnimationPriority: 2, // Needs to complete before the next frame. HighPriority: 3, // Interaction that needs to complete pretty soon to feel responsive. LowPriority: 4, // Data fetching, or result from updating stores. OffscreenPriority: 5, // Won't be visible but do the work in case it becomes visible.&#125;;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useEffect小试]]></title>
    <url>%2FReact%2FReact-Hooks%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前序实习了3天，感受到了互联网公司的快节奏React hooks，TS，Sass是基础，而自己又不太熟，需要补补课React hooks之前看了一下官方文档，感觉非常清晰，然鹅做起项目来，还是有点不大理解，需要捋一捋 useEffectreact只会在浏览器绘制之后运行effectsuseEffect函数在每一次渲染中都不同，对应的state值也只属于当前那次渲染。一个function对应多次渲染，每一次渲染中useEffect和state都是不同且独立的，每个effect函数看到的props和state都是来自他属于的那次渲染 一次完整的渲染过程，以官网count为例子 组件给react需要渲染的内容，此时count为0，并告诉react渲染之后调用effect函数 react拿到组件渲染内容，更新UI，告诉DOM进行修改 浏览器绘制后告诉react，react运行effect 然后count为1，组件给react count为1时的渲染内容，重复进行 和componentDidUpdate相比，componentDidUpdate的state会指向最新的state，而hooks会指向某次特定渲染的值，这也是闭包的一个应用。如果想在effec的回调中拿到最新的值而不是每次渲染的值，可以用refs effect清理 react渲染id为1的UI 浏览器绘制，我们看到id为1的UI react清除id为0的effect react运行id为1的effect，id变成2上一次的effect会在重新渲染后，被清除，effect的清除并不会读取到最新的props。所以react能做到在绘制后立即处理effect 依赖数组deps因为react无法区分effects之间的不同，只能依靠deps如果两次渲染，deps一样，react会跳过这次effect，也就是只有deps改变，effect才会生效如果deps为空，表示只有第一次渲染会执行effect 依赖撒谎依赖是我们给react的暗示，告诉它effect里需要使用的渲染的值，如果effect使用了count，但依赖数组里没有，会出大问题。比如设置定时器，定时器调用了state但没有在deps里面标明，这样effect不会重复调用，每一次setCount里count都是常数123456789101112function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); // setCount(c =&gt; c + 1); 正确的姿势 &#125;, 1000); return () =&gt; clearInterval(id); &#125;, []); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; useEffect发请求12345678910111213useEffect(() =&gt; &#123; async function fetchData()&#123; const result = await axios() &#125; fetchData()&#125;, [])async function fetchData()&#123; const result = await axios()&#125;useEffect(() =&gt; &#123; fetchData()&#125;, []) 请求函数写在useEffect里面容易出现问题，比如如果async函数里面有一个state，UserID，我们需要在deps里面加入，但由于代码量比较大，我们非常可能忘记加上这个deps，然而如果我们把async函数写在useEffect里面，就很直观，程序员可以意识到要加这个间接依赖 如果几个effect调用了同一个函数，可以把函数放在整个组件外面，或者用callback钩子12345678910111213141516171819202122232425function getFetchUrl(query) &#123; return 'https://hn.algolia.com/api/v1/search?query=' + query;&#125;function SearchResults() &#123; useEffect(() =&gt; &#123; const url = getFetchUrl('react'); &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl('redux'); &#125;, []);&#125;function SearchResults() &#123; const getFetchUrl = useCallback((query) =&gt; &#123; return 'https://hn.algolia.com/api/v1/search?query=' + query; &#125;, []); useEffect(() =&gt; &#123; const url = getFetchUrl('react'); &#125;, [getFetchUrl]); useEffect(() =&gt; &#123; const url = getFetchUrl('redux'); &#125;, [getFetchUrl]); &#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在NTU毕业前夕]]></title>
    <url>%2Funcategorized%2F%E5%86%99%E5%9C%A8NTU%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%2F</url>
    <content type="text"><![CDATA[今天是2020年5月2号，算是一个里程碑式的节点，上传了NTU最后一门课text mining的作业，终于可以专心集中的搞一个领域了，有点小开心。博客今天也重新开张了，是时候规划总结一波了 算法学习今天是刷leetcode的108天，目前leetcode刷了207道题，基本都是python写的，力扣刷了140道，基本都是js写的，ScriptOj刷了50道题。本科算法基础有点差，现在刷了一些题感觉还是很有效果的，之后打算继续刷。定个小目标，拿到ntu毕业证之前： leetcode hot 100用js刷完做好笔记 ScriptOj刷完做好笔记 总结常见算法题型，回溯，动态规划，双指针，滑动窗口，树，单调栈，二分法，矩阵和一些小众算法比如摩尔投票等等 力扣有竞赛就打，打tmd 一天1道算法题，多了刷不动 前端学习今天是学习前端的103天，通过实习的项目和这两个月面试的磨练，前端的基础已经搭起来了，接下来主要就是实践。定个小目标，拿到ntu毕业证之前： 把之前面试准备的知识点总结到github 多逛逛掘金和大佬们的博客，提高一下姿势水平 在快手好好搬砖，争取拿个return offer 技术栈提高一下广度，深度现在还搞不定，flutter，react全家桶，typescript，weex，nodejs学一学 一天3道面经题总结，面经永远是最好的学习方式 博客今天是写博客的第一天，1年半没写了，现在要开始笔根不辍起来，定个计划 一周出一篇博客，一个知识点，内容随意，先养成一个习惯 书籍趁着还没正式996，先看点不看会被同行看不起的书，提高一个，一天一章，按顺序看，今年肝完（先立flag，看不完明年看） JS高程，现在看了四章，发现面经好多都在这个上面，哭了 深入理解ES6 Javascript设计模式 JavaScript异步编程 高性能javascript 学习javascript数据结构与算法 你不知道的javascript JavaScript权威指南 JavaScript编程精解 JavaScript语言精粹]]></content>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAP PI (3)]]></title>
    <url>%2FSAP%2FSAP-PI-3%2F</url>
    <content type="text"><![CDATA[PI 是企业服务总线，面向服务 提供B2B（公司和合作伙伴）,A2A（公司内网的系统，各个应用）的集成，non-SAP或者SAP与SAP或者non-SAP的集成 一般一个公司一个PI就可以，如果国际公司，每个地区可能有一个，大部分一个PI 集中开发，集中监控，设计接口复用 负责集成项目的话，先去查backend应用有没有现成的prepackage，ESR content，有的话直接导入PI。谈项目的时候，看标准的接口是否能满足需求，尽量减少开发，推PI的一个优势，大部分solution，sap已经事前定义好了接口，用户在做集成项目的时候，就可以节省很多开发。 Service provider：提供外部service服务的应用（PI向service provider发消息，调用它的服务）Service consumer：对方系统向PI发消息，PI提供webservice, 都是基于webservice的应用系统 PI可以与其他厂商的中间件直连，比如IBM MQ 只要有adapter，就可以连接，比如化学，工业制造的 虚线左边是双栈结构，虚线右边是PI java Noncentral Advanced Adapter Engine 只有连接的功能，还有消息格式转换 ，只是一个runtime的环境，不能独立存在，要么和双栈，要么和java，只运行在java上。图上黄色的都是在java上。Load distribution，分同步异步。 只有business process engine，integration engine和IDoc，webservice和HTTP adapter是运行在ABAP上 ESR：设计，开发接口和接口映射。Design time开发系统定义好，通过传输，测试系统到生产系统。这些object不能够修改在生产系统。 ID：配置，配置消息流，发送接受，通道，用什么接口，需不需要映射。Configuration time 可以动态根据需求做变动，比如value mapping group Web UI：搜索PI已经定义好的接口, Service registry：webservice注册管理, cloud integration content：一些content，可以直接用，cloud的接口，配置用 双栈有3个runtime engine：Integration engine（集成逻辑，pipeline集成管道）， business process engine（消息的关联处理，用到BPM的时候），advanced adapter engine（最初只做连接，没有集成逻辑。到java，集成逻辑移入进来了）。如果用ABAP的就是ccBPM。大部分mapping都是在java栈。abap栈也支持abap mapping。java版本PI的adapter engine自带集成和连接，BPM,BRM另外。 早期是runtime workbench，现在是configuration &amp; monitoring，进行监控和配置 SLD不是PI的组件，而是NW的，SLD对PI非常重要 PI在7.0以前的安装，是先装NW，再PI，到7.1以后，PI集成到NW上了，再把NW configure成PI HTTP AAE就是比SOAP少了个end-loop，所以会比soap效率高 WS消息发送sequence的概念，用于银行，金融 Abap proxy不在PI上面，在backend上面，类似webservice的接口 加AAE的都是abap移到java上的 RFC不鼓励用，只是为了兼容SAP的应用 新开发的接口尽量用proxy，面向OO的方式 如果只是只在backend做查询，才用RFC BC adapter类似于jco Mail 连SMTP service或Exchange service partner提供相应的adapter，直接部署到PI的adapter engine上，基本都是java。比如sea-burger和iWay，EDI基本都是sea-burger。 两个Add-ons：B2B EDI-based（AS2, X.400, OFTP)（国际贸易要求是EDI） 和 secure connectivity(SFTP） EDIFACT是欧洲标准，ANSI ASC x12 是北美标准。 PI各组件没有配置SSO SAP NetWeaver属于basis的管理界面，与我们有关的是java参数的配置 Technical System需要有的：adapter framework，domain，integration directory, integration repository, integration server, runtime management server. 少了就重启相应的component，duplicate就要follow一个note来off 做PI项目时，最少要定义一个product，比如logistics，然后里面包含至少一个component，再定义接口，第三方的产品需要手动定义 Message mapping是pi最难的部分，很多情况自带的mapping方式做不了，困难的时候要写java程序来映射。主要的开发任务是datatype和message mapping，其他都是定义和引用 Determination，agreement是dual stack的，老了，现在直接integrated configuration Message，Idoc，communication，cache，adapter engine status，background job processing monitor user-defined message search configuration: 查询规则，不定义的话只能以message id查询，这些接口传的是业务数据，我的order12345没收到，来找你，你看在PI上有吗，这样可能一天上百个order，message看就只有一个接口，不知道哪个是12345，把业务数据中的字段定义成查询字段。 ccBPM是ABAP Stack的BPM PI Landscape Architecture ModelCentral：一个integration server连接所有business systemsDistributed：一个integration server连接1个或更多de-central adapter engines，engines连接相应的business systems Federated：2个或者更多integration server和相应的business systems 安装完，首先要run一个function units，然后运行PI HTTP Load Balancer Internet Communication Manager (ICM) 看instance profile，PI相关参数，abap stack用al11看参数，smicm看参数设置，spfpar看所有instance profile里的参数和默认参数 NetWeaver-configuration-infrastructure-java system properties 看java的所有参数的设置 双栈的参数很麻烦，要一个一个看，java栈的只需要看icm，gw和SCS的参数 SAP的原则，生产系统只做检查，不做修改，即使知道怎么改，所有操作客户来做 Kernel release在7.43以上，只设一个maxconnection，其他参数会自动计算，7.43以下20个参数需要一个一个检查 Business system一定是从SLD中导入的，business component是直接ID添加的，很多第三方直接BC，但这样选接口比较麻烦，很难找。没找到就在environment里面clear SLD data cache 做完蓝图 SLD创建产品（released） 创建technical system（third party，TS） 创建business system（BS），一般创建两个 ESB创建software component version，import from SLD 创建Namespace SAP三套系统DEV，QAS，PRD 一个PI demain，必须唯一注册以下几个组件 Integration Repository Integration Directory Integration Server Adapter Engine（Central） RWB（Runtime Workbeach） de-central Adapter Engine的数量不限。多了或者少了，PI都不能正常运行。在techinical system-process integration里面 Netweaver - Configuration - Scenarios - Configuration Wizard - PI SLD Self-Registration 进行重新注册 安装完PI应该尽量更新，搜SAP CR Content，cimsap是对数据结构的更新，CRDelta是对产品更新的信息，两个都要下载，patch level要是一样的。导入位置：Adminstration - import - 先导入cim model再导入delta change。 ABAP system，通过RZ70， 推送数据到PI，就填上PI的gateway和host，注册system Java system，通过NWA-HTTP destination，注册system Administrate - settings - datasupplier 看gateway service 和 host 接受RFC的是SLD_NUC和SLD_UC，non-Unicode和unicode acl_mode default 是1的，不接受系统连接其gateway，需要设为0或者用那几个register文件]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAP PI（2）]]></title>
    <url>%2FSAP%2FPI2%2F</url>
    <content type="text"><![CDATA[BPE：message correlation and deals with the processing of messages in ccBPM. IE：routing and mapping and provides central integration server services，handles messages in XML and SOAP protocol AAE：adapters 大多数adapter在JAVA栈上，只有2个在abap栈上，IDOC，HTTP Service Repository：UDDI，还有一些web service ESR：objects 比如 mapping，interface，process definition SLD：landscape，software component version，business system，technical system ID：配置场景 以前是双栈结构，IE，BPE，IB在abap。ESR，SLD，ID在java；7.5之后java单栈 一个service interface对应一个message mapping对应一个message type对应多个data type operation mapping是用来把原始结构转为目标结构，使用message mapping来简化 message mapping有图形化mapping，java mapping，XSLT mapping 和 ABAP Mapping Communication channel determines inbound and outbound processing of messages by converting external native messages to SOAP XML format using Adapter Engine。Two types of communication Channel — Sender Channel and Receiver Channel. The Configuration and Monitoring option on SAP PI tools Home Page allows you to monitor the functions of the integration engine, CCMS integration and process monitoring infrastructure in SAP system. Using Configuration and Monitoring, you can monitor the following functions − Component Monitoring − To monitor different Java and ABAP components of SAP PI. Message Monitoring − To monitor the status of message processing in a SAP PI component. Performance Monitoring − Using runtime workbench, you can monitor different performance measures in a SAP PI system. You can create various aggregation reports. End to End Monitoring − To monitor end to end lifecycle in SAP PI system for a scenario. Message Index Search − You can perform Index-based message search in message monitoring and you can also search based on adapter specific selection, etc. Alert Inbox − Alert inbox is as per the role assigned to a business user and is used for viewing all the alerts in SAP PI system as per configuration. Alert Configuration − Alert framework in C&amp;M allows you to report all the errors during message processing in ABAP and Java. Using alert configuration, you can define policy, if an alert has to be reported for error and to perform analysis or not. Monitoring of Runtime Cache − This is used to view objects in runtime cache. BE（best effort）：同步通信，sender给receiver发送request，然后等待response，否则就不继续了。如果有错误发生了，超时了，sender就会重复发送 同步通信优点：不需要配置response message routing；不需要correlate response to a request；response立即可以收到。适用于reading操作的场景，比如view po 同步通信缺点：失败了需要resend；receiver需要配置check重复message；sender application会堵塞直到收到response或者超时错误；不能适用于配置多个receivers EO（exactly once）或EOIO（exactly once in order，按照business requirement）,异步通信，两个系统间加一个中间系统（队列结构），sender发送request，不需要等待response。如果出错误了，中间系统会负责重发。If required, the receiving system can send a response back to Sender as a separate asynchronous call. 使用场景：创建po，修改po 异步通信优点：保证delivery，会重发；不需要配置check重复message；可以多个receiver；sender和receiver不需要同时在线； 异步通信缺点：不提供及时的response；Response message needs to be implemented and routed separately；In this scenario, the sender needs to correlate responses to request on its own SOAP：PI传递信息的格式：包括一个header和payload，头部包括sender和receiver的信息，payload包括actual data With SAP AS ABAP, each client is defined as one business system. In SAP AS Java, each technical system acts as a business system. Technical systems are part of the System Landscape Directory (SLD) and contain information about version, database and patch levels, operating system, etc. Business system acts as a sender and a receiver in SLD. They inherit the software components from technical systems as products Inbound Service Interface will be dragged to Target Operation and Outbound Service Interface will be dragged to Source Operation.]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAP 演讲培训]]></title>
    <url>%2FSAP%2F%E6%BC%94%E8%AE%B2%E5%9F%B9%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[成功演讲之准备篇为什么会紧张： 负面思考 追求完美 准备不足 缺乏自信 全球十大恐惧前三就有公众演讲，所以没有关系 克服紧张四大心法： 主场意识 焦点转移，不放在别人看法，想法上，完成自己所要完成的 借力技巧，手卡，自然而然的看 回归当下，享受与人分享的喜悦，暗爽 技巧：336，吸气，呼气，临上场，真的紧张时，平复心情 演讲前思考的第一个问题： 什么是你的目的 告知 eg：工作汇报，产品演示，任务布置，项目说明，经验分享，新闻发布等 风格：简洁的，生动的 技巧：金字塔原理，认知心理学 说服，改变听众的态度或行为，使听众接受或者支持你的观点 eg：销售路演，面试，投标演讲，IPO路演，提案建议，竞选演讲等 风格：专业的，积极的技巧：销售技巧，社会心理学 激励，促使听众去追求崇高的目标或理念，使听众相信自己可以做得更好，引发听众对未来的无限憧憬 eg：励志演讲，誓师大会，毕业典礼，公司年会致辞 风格：热情的，鸡血的 技巧：表演技巧，共情技巧 娱乐，给听众带来欢乐和享受 eg：综艺节目主持，脱口秀 风格：幽默的，冷幽默的 技巧：表演技巧，语言技巧，脱口秀技巧 传播，让听众宣传转告（转发） eg：互联网企业发布会 风格：抓眼球的，带梗的，全民八卦 技巧：传播理论，营销技巧 Tips 改变！让别人知道我们所知。好的演讲者分享资料，杰出的演讲者改变观众所知，让人惊艳的演讲者改变观众的信念 演讲三大水桶：主题+演讲者+听众 what is in it for me？ 与我何干？ WIIIFM 找准核心听众，老板，重要客户 预判听众立场，客户很资深的话，从自己 了解听众需求，痛点在哪里 考虑自身立场，仅代表我个人/团队/公司，字搞大些，政治正确，不踩雷 目的：分析听众，了解听众痛点 成功演讲之基础篇 声音 身形，避免摇晃式，左右/前后，避免含胸驼背 站位，无遮挡原则，照顾全场原则，稳定自然原则 非语言信息：适当的手势与演讲相称的表述（自然），眼神（不要闪烁，适度交流），避免眼神只盯着一个人 成功演讲之技巧篇 开场，抓住听众，给演讲定性定调 显示照片 从热点新闻开场 提供权威人物，名言 幽默 利用神秘感 提问 画一张图 一些数据统计 个人感受 画骨，逻辑能力（思维），画骨就是逻辑的力量 时钟方案，以时间顺序安排逻辑，推进计划是不可阻挡的时间流逝 空间方案，地理位置或者视觉区域，使大众能看到地图，从视觉上跟上你的思路。纽约-伦敦-巴黎，家庭-学校-公司，头脑-心灵-双手 三叶方案，三元结构，三段式论证，从不同的方面，层次，或者视角安排逻辑。红-蓝-黄，剪刀-石头-布，老师-家长-学生，员工-经理-客户 钟摆方案，正反合，你描述相互对立的选项，并建立起对合理中间立场的渴望，让你能承认两种相异的观点，然后将观众引向中间立场，从而再僵局中实现行动。太热-太冷-刚好，从一方面-反过来-平心而论 镜头方案，通过视野变化而产生强烈的视觉运动，透过镜头带动听众：从小，中到大或相反方向，个人-小组-大众，首先-其次-第三，城市-国家-大洲，公司-部门-个人。以小见大 互动，“有xxx经历的请举手” 提问，所有的问题不能接不回来，肯定，回复，确认 认可，个人，事实，感受，“这是一个很好的问题”，我相信很多人都有和你一样的a，我理解你的感受。表达处理异议，我理解你的感受，我曾经这么想，后来我发现。 询问，意义，重复一遍，“我有没有回答你的问题” 观点-原因-例子-总结点 结尾，回声 镜头回放 号召行动 个人承诺 价值和愿景 诗意的激励，情怀 一句话总结，公司slogan（年会） 致谢，耐心，创新，支持，走心些 故事，为什么讲故事 讲故事&gt;讲道理 画面感 可视化 感性易经 右脑思维（情感） 难点变得简单 激发好奇心 思辨，挑战 逻辑引发思考，而情绪促使行动 如何讲一个故事？ ​ 具体时间+地点 三幕式结构： 设定情境 矛盾冲突 问题化解 故事五要素： 细节 画面感 悬念 情感，内化现象，引起共鸣，代入感 提炼和升华 我的演讲 三分钟自我介绍： 网络用语不要用，观众很多可能不明白 woc等词不能用 不要走来走去 增加与观众的眼神交流 主题演讲至暗时刻： 站姿，定点（重点） 眼神沟通（重点） 幽默精简 演讲加分点 打动人，情感真实，面带笑容 植入商业价值 讲熟悉的东西 声音好听，语速有变化，不快不慢，语音语调 不跑题，契合 故事性强 手势丰富 结构清楚 时间掌控 考虑听众 有仪式感，不能太放松 nike曲线，有波折，有悬念 看稿杜绝一边看一边挥手的动作 细节到位 说请举手时，尽量自己也要举手 互动环节，不抛地雷，不要放太开，以免观众不配合 成功演讲总结 充分准备 掌握技巧 平和心态 不断练习]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>软技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAP PI（1）]]></title>
    <url>%2FSAP%2FPI%2F</url>
    <content type="text"><![CDATA[Unit 1 PI Architecture SLD(system landscape directory): 负责business和technical system，包括software catalog，landscapes ESR(enterprise services repository): 各种对象，比如interface，mappings，process definitions SR(service registry): 提供各种web服务，比如UDDI(Universal Description, Discovery, Integration) ID(Integration Directory): 配置场景，实现信息交换 BPE(business process engine): 控制信息校准，决定处理哪条message，cross-component business process management (ccBPM)的一部分 IE(integration Engine): 处理ID的信息，包括确定接收方和mapping传入的信息到接收方的接口 AAE(Advanced Adapter Engine): 给adapters提供basis RW(Runtime Workbench): 监控部件和信息的工具 访问SAP PI的方式 SAP GUI，访问ABAP版本的PI Integration Builder，提供了JAVA GUI，在ID中使用，同时还负责版本控制和锁管理 Enterprise Services Builder，提供JAVA GUI，在ESR中使用 SAP NetWeaver Developer Studio（NWDS），SAP的java开发工具，基于eclipse，可以用来查看编辑ESR中的对象类型 浏览器，可以看到配置，监管，ID和SLD SAP PI的下载选项 SLD 在SLD上填写technical，business系统的信息，包括hostname，software component的信息等 SLD的结构基础是CIM（Common Information Model），CIM是由DMTF发展而来（Distributed Management Task Force），DMTF是用来集中管理landscape上的IT系统的 business系统代表发送，接受系统，可以把business系统赋给任意的technical系统 在ABAP系统上，可以把一个business系统分配给每个客户端 business系统被导入ID中，创建完需要assign 一般一个business系统对应一个technical系统对应多个software component business系统中包括software component versions（swcv），每个swcv有自己的接口 ESR object name，software component name，namespace三者决定一个object 除了business，technical系统，product，software component name（在技术系统上run）也在SLD上创建 在software component verison中，创建namespace来存储在业务流程中使用的接口对象 接口对象包括出入接口，还有mapping的细节 可以使用接口：RFC,，IDoc，XSD，WSDL等，可以在ESR手动创建 可以在ESR定义出入接口，如果与出入message不匹配，可以定义mapping规则来结构mapping，有一个图形化的mapping工具，或者可以自己写程序（java，ABAP，XSLT）。除此之外，还可以定义valuemapping，将结构值mapping成入结构需要的值 实现一个场景 创建处理步骤，将出入接口赋给这些步骤，用线连接，可以表示同步或异步连接。 选择出接口给发送系统，入接口给接受系统，再specify一个mapping程序来map出入接口。 这些场景和配置可以当成配置模板，来简化标准场景的实现 Message可以被IE（pipeline processing）或者AAE处理，取决于adapter和功能。 ID ESR只存储与软件成分开发对象相关的信息。对于这些对象，是否安装软件成分或者安装在哪个服务器上不重要，为了使业务流程在分布式的环境中运行，需要存储在集成目录中的配置对象 ID负责发送方，接受方，adapter和其他的一些配置（发送者协议，接收方确定，接口确定，接收方协议） 可以提供一个对象，这个对象绑定了所有的配置场景中的配置对象，配置场景使得配置对象更加容易使用 IE： 连接系统前保证接收发送者的message，发送到接收者message都是XML格式（PI format） Local IE 是SAP Basis 6.20以后的，可以集成XML格式，直接交换信息，使用SAP Process Integration proxies Adapter是另一个连接方法，将message转成xml，输出xml再转回去。可以使用合作伙伴的adapter 处理过程pipeline 当一个符合format的message到了integration server时，processing开始 配置数据决定sender和sender interface，这叫logical routing 如果有多个sender，系统复制message，对于每个receiver，message从send interface map到receiver interface Pipeline决定技术方法与sender通信，这叫technical routing 最终系统发送信息到指定的系统或者adapter 在一个使用企业服务的应用中，PI作为一个企业服务的bus来促进各个服务之间的相互调用，接口集中存储在ESR中。PI和SAP Composition Environment都使用ESR。 SOA(Service-Oriented Architecture) 面向服务的架构是一种软件体系结构，应用程序的不同组件通过网络上的通信协议向其他组件提供服务。通信可以是简单的数据传递，也可以是两个或多个服务彼此协调连接。这些独特的服务执行一些小功能，例如验证付款、创建用户帐户或提供社交登录等。 面向服务的架构不太关于如何对应用程序进行模块化构建，更多的是关于如何通过分布式、单独维护和部署的软件组件的集成来组成应用程序。这些通过技术和标准来实现，通过技术和标准使得组件能够更容易地通过网络（尤其是IP网络）进行通信和协作。 SOA架构中有两个主要角色：服务提供者（Provider）和服务使用者（Consumer）。而软件代理则可以扮演这两个角色。该Consumer层是用户（人、应用程序或第三方的其它组件）与SOA交互的点，和Provider层则由SOA架构内的所有服务所构成。 SOA首先在90年代中期得名，当时一家名为Gartner Group的公司认识到了这个软件架构的新趋势，并在全球推广。通过这样做，他们设法大大加快了这种架构模式的采用和进一步发展。然而，使用分布式服务作为软件体系结构的最早记录可追溯到二十世纪80年代初。 现在比较推崇微服务（micro service），可以把微服务当做去除了ESB的SOA。ESB是SOA架构中的中心总线，设计图形应该是星形的，而微服务是去中心化的分布式软件架构。SOA集中数据存储，微服务独立数据存储，轻量级协议，通常云平台，解耦。 Unit 2 SLD知识点 software component是模块化实体，可以用在不同的产品上，是进一步开发的组件，所以有各个版本。 SLD中，独立的对象叫做软件特性，表示产品版本和软件组件版本的关系，复杂的软件特性让你能够展示复杂的产品。 事务码SLDHTMLGUI连接SLD。 Software Catalog里看产品组件版本信息，SAP的自动导入，不是SAP的要手动导入. SAP Service Marketplace提供最新的更新，应该2年导入更新一次。 software component的外部接口信息存储在ESR中，会创建namespace，来标志每一个接口对象。 接口最主要的对象是service interface，还有服务操作，信息类型，和数据类型 product和software component是在系统级，因为sap系统的发展对象不是客户特定的 注册Tech系统的前提是激活了SLD的data supplier bridge，配置完成后，specify RFC的gateway 配置data supplier bridge：RZ70，ERP6.04之后，也表示收集产品版本的信息 Product versions are software units that can be installed on your system and do not run independently of other software(错误) 在SLD上可以创建product和component，再assign给technical和business system The Enterprise Service Repository within the software component version stores detailed information about the external interfaces of a software component The Java component SLD data supplier is deployed and started for the SAP NetWeaver AS Java server when using a single SLD for your entire system landscape, define groups of business systems and transport targets so that you can map and manage each part of your system landscape independently Unit 3 ESRUsage profilesUsage profiles用来view和work with指定的对象类型，软件部件版本，模型过滤器。其他的会被隐藏。在ESB中，登陆后选择一个，之后可以改。 3个predefined的usage profiles： Service Development：促进建模和接口开发 Process Integration：跨组件过程建模，接口开发，mapping，adapter对象 Unrestricted：SD和PI所有可用的对象类型 类型 Data Type: Freely modeled data types Core data types (CDTs) Aggregated data types SAP 用 CDTs 和aggregated data types来创建enterprise service的signature; 一个CDT定义了一个主要部件（也指内容部件）和一个或者多个可选的补充部件; 数据类型是接口的基本组成; GDTs的基础是CDTs，可重用，更加广，需要重定义; CDTs不是应用特定，而是上下文无关 Message Type: ​ 描述PI消息的结构，决定消息的根元素，当成单个或者复杂的数据类型，出入接口都能用。ESR中提供XSD版本的消息 Service Interface: ​ 使用服务接口来描述操作 WSDL（Web Service Description Language）,接口在WSDL中可用，WSDL中，消息类型变成消息元素，数据类型变成类型元素，接口本身变成端口元素; Context对象,封装了XPath的表达，另一种舒服的表达，有意义的名字，和公司相关 创建接口三个方法： Service interface and service operation External definition Imported objects 创建服务接口和服务操作： ESB SAP NetWeaver Developer Studio 外部接口定义可用： WSDL XSD DTD 同步与异步同步处理： 发送系统发一条请求，等一个回应 直到收到回应或者错误之前，发送过程是堵塞的 服务接口包括至少两种消息类型，一个发送请求，一个回应（或者错误信息） 为了防止连接错误，不知道数据记录在目的地有没有完全处理 发送系统负责处理错误，而不是PI 异步处理： 发送系统发送请求，不等回应 发送系统可以持续工作，和接受系统处理消息分开 只要PI选为agent，当消息发送后，接收系统不需要可用 这时，GUID附加在data上，和data一起存储，接受系统可以判断消息记录是否在连接被中止之前被处理 发送接受系统需要支持重启 QoS是流程集成XML消息的处理模式，可以区分同步处理和异步处理。 同步处理的QoS叫做BE（Best Effort），可以与sRFC相媲美。在异步场景中，处理序列也很重要。这也可以指数据记录的内容依赖性以及性能方面。如果不同时发送数据记录，性能就会提高。为了实现消息的序列化，数据记录被放入队列。在使用PI时，QoS总是按顺序排列(EOIO)。在RFC场景中，排队。RFC(qRFC)是一种特殊的tRFC。 通信有状态通信（指的是接收端的消息而不是PI）： 不支持提供者局外人的状态 允许存储消息的状态信息，未来这个信息可以用来处理其他消息 无状态通信： 在消息成功处理后支持提供程序端的状态 消息接收器的运行时不支持使用消息的处理时间存储状态信息。 SAP ACK: ACK是异步消息的确认（对于同步信息，发送者都会收到response） 系统ACK提供发送消息的信息 应用ACK提供消息在应用中处理的信息 请求ACK只在代理接口和集成处理中生效 返回ACK只在代理接口，集成处理，一些适配器中生效 通过异步通信，发送方系统不会收到消息是否到达收件人的ACK，目标系统中也没有关于业务处理的信息。例如，发送方使用sap pi异步发送消息。发送方只收到技术响应确认消息已被sap pi接收，但它没有说明消息是被成功转发的还是被代理的。目标系统应用。为了提供这一信息，sap pi方便了ACK的使用。 下列条件适用于请求确认： 在代理方法调用中指定所请求的确认类型(应用程序或系统，肯定或否定，或替代者已完成)。 确定使用方法调用发送的消息id。 使用消息id并在正在运行的程序中直接检查消息是否已返回。 缓冲消息id，然后检查通过主动使用消息id接收到的任何确认。 ACK的确认 代理服务器自动创建请求ACK 一个积极的系统ACK在消息传到目标系统时创建 一个积极的应用ACK在执行代理服务器方法没有异常发生时创建 如果上述条件没有得到满足，一个消极的ACK发送 接收者适配器，运行在适配器引擎支持系统ack，当其被发送者要求 如果信息成功的被适配器处理或者处理中异常发送，这些ack被触发 接收者适配器不支持应用ACK（除了RNIF和CDIX外） Message Monitoring ACK—Status 中可以看到ACK的请求，发送情况 在reliable messaging下，可以看到ACK是否被请求 ACK没有被作为monitoring中的消息列出来，只是一部分 题目You browse for services in the Enterprise Repository Workplace You can import interfaces with structures that have not been defined using Web Service Description Language, eXtensible Markup Language Schema Definition, or Data Type Definition into the Enterprise Services Repository（false） stateless and stateful communications are available basic interface patterns Unit 4 Mapping in ESR知识点 Message mappings：使用图形化mapping工具来进行mapping。您可以使用message type、outbound interface或inbound interface、Idoc或RFC签名作为source和target结构。也可以导入xml或xsd作为template。 Mapping functions：例如将两个字段合成一个字段或者转换日期。在目标字段mapping中，为每个target字段创建rule。这些rule定义用于确定结果值的source字段。这些rule不是附加到souce字段，而是附加到target字段。每个source字段可以在任意数量的target字段映射中重用。然而，每个target字段只有一个目标字段mapping。 Structure mapping：当发送者outbound interface与接收者inbound interface不一样时，需要分配语义相同的字段。 Value mapping：转换rule的mapping过程，以转换为目标格式 Operation mapping：创建interface的连接。在操作映射中，您通常可以引用outbound的service interface、IDOC或RFC接口作为outbound interface。您可以引用inbound的service interface、IDOC或RFC接口作为inbound interface。通过使用message mapping、XSLmapping、java类、abap类或abap xsl转换的mapping过程。您可以在操作mapping中引用程序。 异步的operation mapping 同步的operation mapping 在同步接口的情况下，有一个用于查询的数据包，一个用于来自服务器同步接口的response。因此，operation mapping必须包含request和response的mapping程序。客户端outbound interface包含resquest的outbound message和response的inbound message。这些入站接口包含用于查询和响应的出站消息的目标消息。如果客户端出站消息和服务器目标消息没有相同的结构，则创建一个映射程序。如果服务器出站消息和客户机内消息没有相同的结构，则创建一个映射程序。您可以依次执行几个映射。提示：如果在服务接口中使用错误消息类型，则可能还需要一个映射程序。 异步场景说明了sap管道是如何工作的。sap pi中的处理和配置步骤是本文的重点区域。sap pi以专门的xml格式接收文档，标识接收方或接收方，并以特殊的XML格式发送每个接收方系统的一个文档。发送方系统用于将文档传输到sap pi的数据格式。有各种适配器可用于转换文档。对于XML格式，即sap pi预期。同样的原则适用于接收系统。如果需要，适配器也可以将文档转换为接收方支持的格式。文档总是在sap pi中以相同的方式处理。这是用基于一个简化的材料主数据分发示例的演示和练习来说明的。发送者系统由一个http剪贴器模拟。一个文件是为一个虚拟接收系统创建的。 在设计时创建的对象 所有要用的软件组件的名字都输入到SLD，再到ESR 所有软件组件的出入接口都在ESR可用 一条mapping规则对应每一次数据交换，如果接口结构不同，创建mapping程序 PI场景的好处 支持绑定ESR使用的接口和映射。 提供业务流程的图像overview。 提供配置的可能模板。 Actions 定义actions，map一个业务流程，可以用在应用组件 把出入接口赋给actions 一个连接应用组件actions的场景，这个连接specifies哪个出和哪个入相匹配，用哪个operation mapping 题目You can import external XML files into the message mapping as structure templates You do not have to know the exact number of systems in a system landscape when you design a scenario in the Enterprise Service Repository at design time. Unit 5 ID配置视图 业务系统在SLD中创建，每个业务系统匹配一个技术系统，业务组件在ID中创建 配置视图包括出入接口和对应系统 在ID中对配置视图进行配置 用AAE来创建配置视图 在配置视图中，重点是在物理系统环境中实现场景。配置视图确定要使用哪个系统和出站接口向不同的系统和内部接口发送消息。您可以将发送方和接收方指定为业务系统主体作为业务组件。 您可以在集成目录中存储用于集成场景运行时的配置数据。该数据包括消息发送方和接收方系统的表示。在SAP流程集成中，消息的发送器或接收方有三种类型。 通信组件类型PI的三种接收者和发送者 业务系统 业务组件（业务服务） 集成流程 集成场景的配置数据放在ID上面。 业务系统、业务组件和集成流程可以是消息的发送方和接收方。集成流程运行在集成服务器的业务流程引擎(BPE)上。这意味着，对于集成过程，集成引擎清楚消息来自何处以及消息从何处发送。这不适用于业务系统和业务组件。指定发送方或发送方的信息。可以联系到的接收方通信组件必须存储在集成目录中。此外，必须将消息转换为目标系统理解或转换为流程集成XML消息的格式，然后将其传递给集成服务器。此任务由适配器执行，您在其中定义内界或传出消息适配器的配置对象称为通信通道。 创建通信通道 选择通信组件。指定要为其创建通信通道的通信组件(例如，业务系统)。 输入名称。输入通信通道的名称。如果可能的话，选择一个不言自明的名称，例如rfc_send。 选择适配器类型。指定连接详细信息(例如，用于文件访问的文件适配器)以及它是发送方还是接收方。 选择适配器引擎和协议。除了中央适配器引擎(CAE)，您还可以有其他本地适配器引擎。您还需要输入传输和消息协议的详细信息，如Exchange基础设施(Xi)2.0或XI 3.0、网络文件系统(Nfs)或文件传输协议(Ftp)等)。 输入特定于适配器的参数。 为每个适配器输入额外的详细信息(例如，文件接收者的目标目录)。在导入业务系统时，可以指定是否生成标准通信通道。一旦生成通信通道，就需要为每个业务系统输入准确的参数和自定义信息。 AAE（central，noncentral or advanced）are used for creating the configuration view for the integrated configuration。 Unit 6 ID configuration for ABAP知识点ID中的对象： 发送方协议 接收方确认 接口确认 接收方协议 除了Integration Builder的通信组件(发送方和接收系统)和通信信道之外，在ID中还需要接口对象来处理来自IE运行时的传入消息。 发送方协议不一定需要（当使用代理接口的时候） 对象一定要定义 如果您想要验证消息针对已定义的模式(在自定义中)，IE或AAE将此作为消息处理的第一步 在传入消息的情况下，管道首先对接收方确定对象进行评估 配置场景是可选的，而不是运行时相关的。基于参考配置，配置场景提供用户对所需的业务场景对象的overview。 ABAP Runtime Engines: Integration Engine: SAP PI的运行环境接受进程，传递XML消息 Central Integration Engine: SAP PI的运行环境负责处理步骤，比如确认接收方，用Central pipeline接口确定 Local Integration Engine：PI代理信息的运行环境，在SAP的后端系统，使用SENDER or RECEIVER pipeline来实现与PI的数据交换 Pipeline：IE执行的一系列消息处理步骤 Queues：对于异步处理，IE的信息通过queues来处理 IE属于SAP流程集成的运行时环境，用于根据您所配置的业务流程交换消息。您使用Integration Builder的配置目录创建您的配置。XML消息的接收方是在入站处理期间的逻辑和技术路由中确定的。进一步处理取决于确定的接收方数量。 Queuing in pipeline processing: The inbound SAP Process Integration XML message is first placed in an inbound queue and then sent to the pipeline. After a message from the inbound queue has been read, logical routing takes place and if necessary the message is split. The message is placed in an outbound queue. The outbound queues serve as inbound queues for the processing steps-mapping and technical routing of the pipeline. The message is placed back into an outbound queue assigned to the message receiver. The message is sent to the receiver through an adapter or sent directly by using the proxy technology. ​ SOAP standstard (Simple Object Access Process) Define how XML messages are structured Conclude a header that contains information, including errors, in the form of message attributes A HopList detailing the stages that the document has passed through, and runtime and performance information. The actual application data (payload) is contained in the attachments SOAP message: Header Main: Sender Service and Sender Interface for receiver determination(additional Party attribute for B2B scenarios) HopList: the stations through which the message is forwarded are logged Reliable Message: QoS(quality of service) defines whether the message is processed synchronously (Best effort) or asynchronously(Exactly once) by the pipeline. In case of asynchronous processing, you also have the option of processing with serialization(exactly once in order) Body: a link to payload, which contains the actual application data. Payload: actual application data in the structure of the outbound interface. Message transfer to PI Proxy sender: local IE sends it directly to the pipeline by using HTTP(s), no need to convert Sender uses an adapter: adapter in AE converts the message sender format into a sap PI XML format. The adapter then transfer the message to the pipeline by using HTTP(s) Sender sends plain HTTP: a service sends an XML document to the HTTP service Sender uses an enterprise service or a web service to address SAP PI. PI now supports new standard WS-Reliable Messaging (WS-RM) using its own, newly implemented inbound processing on the IE Usually a message is transferred to the pipeline in a special SOAP document format by using HTTP(s). The XML document is received by using the Internet Communication Manager(ICM). The remaining pipeline steps are defined by the configuration in the IS. Ways to determine a receiver Cancel message processing with an error(restart possible) End message processing without an error(restart not possible) Continue with message processing with the following receiver. You can name an alternate receiver Communication party, communication component, interface and namespace 决定一个receiver XML Validation 只在JAVA栈 同步异步没有区别 In the sender agreement Takes place in the pipeline processing of the IE Takes place directly on entry to the AAE(JAVA) In the receiver agreement Takes place in the pipeline processing of the IE 题目 You create your configuration using the configuration directory of the Integration Builder. The receiver of an XML message is determined in the logical and technical routing during inbound processing The communication profile objects list the cross-scenario configuration objects, which include communication components and channels You can display the processed messages in message monitoring Communication party, communication component, interface and namespace uniquely identify the receiver determination If more than one receivers is determined by the receiver determination, the message is copied for each receiver after the interface determination. This is known as message branching Unit 7 ID configuration for JAVA 大家注意！！！ classic的才要determination和agreement，现在只需要integrated processing，也就是integrated configuration！！！一步到位！！！不能都有，会有冲突报错！！！真tm6！ 问题 Advanced Adapter Engine perform Integrated processing and Routing Advanced Adapter Engine Extended is a cost-saving option compared to a full installation of SAP NetWeaver Process Integration When an integration flow is complete, it is deployed to the runtime, where the actual execution of a process integration takes place Unit 8 Operation of PImonitor类型 message overview: provides an overview of the message processing during a specific time period and aggregates messages by processing status end-to-end monitor: monitors the infrastructure components of SAP NetWeaver PI and the path of individual messages through these components from start to end component monitor: provides insight into the health status of the individual components of SAP NetWeaver PI integration process monitor: provides insight into the execution of integration processes in the business process engine(BPE) and displays aggregated and detailed information about processes and process instances background job monitor: provides an overview of background jobs specific to the BPE message monitor(database): displays the details of message processing on the IE performance monitor: displays the performance of message processing on the IE cache monitor: displays the cached object on the integration engine cache,AAE cache, and mapping runtime cache IDoc monitor: provides the details of IDoc messages processed on the IE and AAE System Landscape Directory(SLD) registration checks: Checks if the components of SAP NetWeaver PI were registered correctly during the technical configuration phase(you can apply corrections to the registration as well as register further components) Security data achiving: enables the administrator to configure the archiving of messages that are processed by the AAR processes and that use secure multipurpose internet mail extension(S/MIME) security 题目 Data archiving cockpit is included in operation management component monitoring provides a uniform interface to monitor ABAP and Java component integration process monitor is used to display the aggregated and detailed information about processes and process instances]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAP Service Delivery]]></title>
    <url>%2FSAP%2Fservice%2F</url>
    <content type="text"><![CDATA[service流程 service request，TQM（technical quality management）的任务，和客户沟通，了解客户需要什么service，了解需求，创建service plan 和 service order，提出最初需求，很多不是技术出身 scoping，OSM和scoping member（COE各个leader和manager）提出，具体化需求，需要多少人天，和TQM协商，使用的技术，onsite还是remote staffing，OSM的任务，使用RPA，通过schedule set看到人员availability，哪段时间有空，然后让人员book他，也会和leader和manager沟通，公开透明的 delivery，COE宗旨要求所有的service需要在客户的solution manager上delivery，坦白说从来没有做到过，因为有时客户没有solution manager，或者不能用。万一onsite的时候客户的solman用不了 ，第一可以通知TQM重新把plan重新order，把solman定义为SAP的，但是我们的solman不与客户系统直接相连，第二个和客户协调，在deliver service之前就修好。如果是在是意外情况，可以用一个word template去写，一般back office会reject，但发生不少，还是会technical review，但很麻烦，写的不好还要打回去改，所以说尽量不要这样做 QA，COE service的KPI，最后一天要给客户report slice，一周以内给客户report，很多同事solman都不连，笔头记录，强烈建议每天在solman上maintain，business process，issue。最好最后一天已经把issue management已经写好了。最好不要增加大家的workload。现在只judging红灯的report，中国客户是back office自己judging，东南亚客户MCS新加坡同事参与进来。对于黄灯和绿灯不会做judging，除非有判断分歧，这时候要开judging meeting，但红灯情况不多，因为有很多服务是来避免这种情况，比如IV。一般实施过程中如果买了我们safeguarding的服务，很少会在后面还发生红灯情况。QA第一件事先查看solman usage，然后再report judging。提交QA request的时候状态是in process by QA，最终改成QA completed handover，OTL（onsite team leader），上交report给TQM和OTL，后续打电话check feedback，service方面的需求尽量找TQM，而不是直接找OTL，虽然OTL也有资源，直接找OTL的情况也很多，但这是不提倡的 Incident Handling 在BCP中帮客户创建incident 客户有时完全不critical的问题也会报very high，如果是maxattention或active embedded的客户，issue会进入到RCA team，我们组轮流派人RCA（route cause analysis），在9楼等着接电话，这都是非常critical的issue 我们的responsibilities是只负责产品的error，做了一件事情报了错，而且不是配置错误，是产品本身的错误，我们才负责，如果你问我要怎么做，怎么做一个备份，月结etc，没有义务免费回答 action plan time（APT），very high的情况给4个小时，action plan很可能是需要客户提供一些东西，而不一定是solution initial response time（IRT），接到service，告诉客户我们已经看到这个incident了的时间，very high 一小时 maximum processing time（MPT），包含客户和我们处理的时间 这些时间会用红黄绿灯标志，红overdue，黄还半小时，绿没事]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAP Value Assurance]]></title>
    <url>%2FSAP%2FAssurance%2F</url>
    <content type="text"><![CDATA[知识点 价值保障：对sap的新产品的一些服务，针对S/4 HANA On Premise S/4 HANA Cloud迭代很快，每个Q都有一个新的版本 S/4 HANA On Premise每年一个版本，1511，1610，1709，1809，基本都是9，10月份 现有的ERP在2025年maintain会结束，希望现有ERP客户向S/4 HANA 上迁移，但迁移不是一蹴而就的，底层架构不一样，表结构 SAP主要是卖软件的，不是负责实施的，但会提供服务，VA就是一个服务包，是保证客户快速有效的使用我们的产品，体现产品的价值 客户需要付license和maintain费，17%-22%，叫企业级服务，客户出问题可以给SAP ticket，SAP给支持，包括remote和onsite，来delivery 客户还可选择超过22%的钱，相当于VIP客户，可以采购更多service，分为maxattention和active embedded active embedded是少于300人天，maxattention大于300人天，COE服务的全是maxattention客户 还有一些professional service，顾问服务，因为ERP不是即插即用的，客户买了软件，装完之后，需要做后台业务上的配置，包括主数据的配置，业务流程的配置，这需要咨询，和客户的应用客户进行访谈， 把客户的想法在系统中体现出来，但COE主要还是做PE的service，VA是PE的一部分，IV也是PE的一部分。PE（premium engagement） SAP solution manager集中进行service，solman S/4 HANA现在推崇除了SAP kernel，其他所有部件都放在云上，现在并没有全部在云上，有两个版本OP和Cloud两条腿走路，APO将来会被3部分取代，S/4 kernel，IBP，还有一部分直接被简化掉。SCM采购部分会被Ariba取代，ECC里的HCM被successfactor取代，整体而言核心都放在kernel，其他全部在云上面 SAP的战略咨询是基于SAP软件的路线图，而麦肯锡咨询是偏业务 IV服务分4种： plan and safegound，最便宜，计划和保驾护航 accelerate technical implementation，技术实现 accelerate functional realization，业务实现 innovate，最贵，大于1000人天，有新的idea，和sap一起联合创新 客户基本都要自开发，写代码调用sap的接口，SAP的原则是标准的支持，自开发的不负责，有对应服务包帮你改 派你做什么service，就去SAP Jam VA link中心查相关的source Road map 一些服务包 innovation strategy &amp; roadmap: 企业战略层面规划，麦肯锡是业务方面的战略咨询，SAP是基于我们的产品的，客户的需求结合SAP将来产品路线图，来进行digital transformation。3-5年的基于sap产品的规划。针对客户包括instore客户或者新客户 value &amp; implementation strategy: 项目层面，instore base的客户，不确定搬到S/4之后，有什么好处，有一个工具叫SAP Readiness Check，让客户跑了之后检查ECC版本和S/4版本的变化。对于已有客户，有三条路，系统迁移，重实施，架构转换，基于现在的情况，哪种最合适，这是这个服务最主要的目的，根据现有的业务需求，场景以及sap产品的结合，做一个打分，来决定走哪个路线。 scoping workshop &amp; prototyping: 如果客户觉得都行，可以做个POC，来比较一下，实现一个场景来看看会发生什么变化 migration planning workshop: 客户决定做系统迁移，跟客户讨论，在技术上要做哪些准备，在业务上哪些是一定要动的，给出一个项目计划 transition planning for new implementation: 客户决定重实施 technical architecture &amp; infrastructure: 架构上的讨论 analytics architecture: 根据需求，做出分析，用哪种产品 data migration architecture: 数据迁移服务 custom code management architecture: 帮客户改自开发代码 S/4 HANA客户现状（COE内部机密）截止2018年9月17日，现在S/4HANA项目一共有4281个，上线了的是2117个 ，431个已经是refs（提供客户案例，分享给其他客户）。其中3210个是OP, 基于cloud的只有430多个，上线了的只有117个，SAP cloud的路还很长。中国有506个S/4 hana客户 （实习生没有权限看，manager培训上说的）]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAP Integration Validation]]></title>
    <url>%2FSAP%2FIV%2F</url>
    <content type="text"><![CDATA[方法论五大维度： Data consistency management 系统时间，订单以时间戳追踪，外围，内部系统，Head（列）和item（行）需要同步commit。外围系统同步订单到中央系统，中央系统不会同步到所有的外围系统。直接改中央系统，会发生问题。解决方法，每晚后台作业，抽出A,B系统数据进行对比。更新完整的信息块，logic unit of work。 Exception management 提示要到位，提供引导性步骤。定位异常位置，5个小灯，哪里红了一目了然。创建instance追踪issue。SAP非常重要的问题：back office有三个时区，中国，欧洲，美国。无缝连接，不加班，晚上下班欧洲的接班，早上起来接美国的班。一般和运维的人打电话。Incident resolution 就是便利贴，需要解释清楚自己做了什么，还有什么问题，才可以接着做。 System integration and queues 系统集成，队列问题，接口问题，同步异步，两个系统信息如何传达，完整信息块，先后逻辑正常，RFC call。系统集成，设计模块很多，很多是外部系统，sap不能cover，只能进行监控。业务性能用KPI来定义，有一个阈值，光看客户主观感受不能判断，KPI就是一把尺子，超过了这个阈值找SAP才有用。 Performance and scalability 客户问题百分之80在这里，快与不快，网络问题，数据多，业务数据并发，用户量大，性能下降，订单有10个行项目，10个的时候1s，100个的时候就是10s，这就叫好的延展性，差的可能要一分钟，反应慢，按回车等很久（这种情况很多），代码，数据库，业务逻辑。 End-of-Day and Volume Processing 批量处理，日结流程（工程，超市等），货架，材料消耗盘点，月结保驾护航，很多企业年底买sap这个服务，平安稳定的月结或年结，后台作业，有依赖关系，先后逻辑，正常时候没问题，8个小时一个订单2小时，但异常情况，重新开始，从哪里开始，断点续传，好的程序前54成功，55失败，则做56，银行部门，后台作业没跑完问题很大。报错后能不能重启的能力。 知识点： IV的顺序：先从这五个维度测量，分析，给建议，改好，验证，不对就循环往复。 End-to-end：业务上面讲，一个人买你的东西，给你钱，拿到货，开发票，运货，开始使用，后期维护质保，整个循环；IV系统也一样，完整的服务业务。 准备（定义scope）-蓝图-实施（定制化，配置，开发等）-测试（单元，集成，用户等）-切换（数据迁移）-运维（改进），IV从集成测试开始，因为系统间已经可以联通。合作伙伴做的项目，IV不一定可以做成这样，看客户是否强势，强势的话会要求实施方配合sap的工作，否则要一起协商进行。店大欺客，客大欺店。 SAP自己实施项目或者合作伙伴（IBM, AC, 汉德等）。新产品，推广产品，倾向于自己做。 主营业务判定：进销存，制造，订单，报销 技术判定：用户量，数据量 issue分优先级：very high（不修好业务做不了，不能上线），high，middle，low wall-to-wall：机房墙到墙，装在屋子里的东西都要管，ui5 client，sap gateway，abap application，sap hana。 OCC：运维中控制中心，反复监控，IV告诉你哪里volume很大，哪个接口很脆弱，哪个地方自开发程序太多，哪里对业务比较重要。 DBS是卖服务的，以前都分一个一个小服务，现在提倡one service，当然买小服务包也许。 Technical Feasibility Check（技术可行性检查），Technical integration check（系统集成检查）是SAP卖的比较好的服务，卖的最好的是Business Process Performance Opt，性能，流程优化，DBS的看家本领。懂点业务，知道取数逻辑，知道算法，看的懂代码，懂数据库的最好，一定要会trace，其他人不会，但SAP DBS的人一定要会。 客制化的稳定性，优化程度，性能，数据一致性，异常处理等等不如标准程序好，千锤百炼，进化的比较好。但要考虑实施方的利益，如果都标准化了，单子就变小了，人天变少了，甚至不需要开发，利益就减少了。但从sap的角度，当然希望客户系统干净稳定，持续运行。 IV Dashboard：全是绿灯最好，红骷髅头是very high，红色是high，不至于影响到业务发展不下去，灰色表示还没做，或者out of scope，不需要考虑。打绿灯需要勇气，sap最难的是发现不了任何问题，这意味着得打绿灯，意味着出了问题就打脸了。 但打绿灯需要各部门的同意，需要商量，团队作业，比如back office，不用担心，都需要验证的，Senior的同事带junior的同事。一个绿灯，表示包含的step全是绿灯，有一个step红，最终就是红灯。 IV人员分配以及计划表格： 这个图有时候自己画，有时候运气好是客户给的。跟业务leader访谈问出来的 灰色的是第三方的，黄的是sap的，外部红点是接口，里面是步骤。需要行业相关的知识。 Management summary：各个地方的服务都要这个。第一段这个客户是谁，用了我们什么产品，想达到什么目的，现在什么状态，核心业务。第二段IV服务什么时候开始，关注了哪些问题，做了哪些检查，有什么进展，目前什么状态，如果有关键问题，下面罗列出来。第三段后面还有什么东西需要注意的。SAP的经典行文八股文，为了让别人迅速理解，便于对接和交付。 找归档过的问题，很难碰到新问题，SAP这么多年，开创先河的概率极低，一般系统里都能找到。Findings/current situation，risks/impacts（一定要业务相关的，不能只说程序闪退，要说明如何影响到自己的业务，比如无法定机票，2000用户无法报销），recommendation（应对方法，可以写上note号，不要求你一个人修好，而是描述清楚，便于后面senior的人处理），status（new issue，in process，closed等等）。 技术分析 ST12知识点： Trace的T code是ST12，烂熟于心，记不住就可以离职了 百分之80的工作是做trace，百分之20是分析trace Trace记录每个语句，call了多少次 好的情况是abap（application数据处理），database（取数据）五五开，如果abap是0，database是100，就是纯粹打印数据库全部数据，没经过加工，不合逻辑。一般关注的是平均值，总量，销售额宏观的东西。如果展示逻辑比较复杂，界面复杂，加个system平均分也行 跑过几十万次的语句也很常见，因为是公用的，累积出来 Gross指货物净重，net指的是包装的箱子重量。这个箱子整个就是function，function是空的，net就指function本身的时间，gross% = 1 – net%。最上面的语句就是最大的箱子，就像俄罗斯套娃，下面慢慢变小 Gross = net，比如select语句，因为不可再分了，没有壳，最里面的套娃 没标type的都是abap语句，还有sys，db，都会标出来 Show/hide中可以选择显示出每个语句的简介 Last changed by可以显示作者，如果是sap，表示没人动过的，大可以放心，如果是其他的，就需要留心了，和标准程序不一样，需要重点看 上面两项需要自己手动显示，默认是不显示的 可以切换为per module，module里面的module按照顺序排列，外面还是按时间量排列，第一个module是最大的套娃，里面包括其他套娃 Server一般都选all server，选指定实例的情况也有，就是出了玄学，其他实例都行，就这个不行的时候 Tasktype，username等，来提高trace的纯度，直接筛进关键部分 用user/tasks进行trace的情况：事情简单，逻辑清晰，知道程序什么时候运行，谁在运行，拿到用户ID，知道要做什么，用户可控，最好再旁边，追踪语句，module 用workprocess进行trace的情况：不知道用户是谁，不知道在干嘛，只知道客户运维部门给你打电话，我的系统现在很慢，怎么回事。这个时候就看他们哪些进程跑得慢，不用输入多少选项，就一个comment和server，追踪进程 用current mode进行trace的情况：很苦，没人帮你，客户可能很忙，没空帮你跑业务，告诉你T code和测试数据，particular unit一定要打勾，表示只关心特定的单元，只关心按了某个按钮 用schedule进行trace的情况：客户说一个作业每次都很慢，晚上10点开始，时间还很长时，像配置后台作业一样，这是for background，对于for workprocess，for user/tasks，也是，指定时间，不用盯着 Trace很耗资源，一般配置好参数（缩小范围），按start，等其他人做好操作，再stop，就得到了这段时间trace Trace 有时duration是0，因为这时进程已经得到cpu了，trace就像是门卫，有些人已经进去了，门卫登记不到了，说明时间太短了，需要拉长时间，不是问题 可以看sql，abap，sys各自的summary Sql summary 里的redundant指的是，select语句被调用了100次，但是94次while条件是一样的，redundant越高，可优化程度越高，因为每次while条件给的是一样的，为什么要去db取呢，除非时效性要求特别高，通常不会这样，既然94次一样，可以用1来代替，不必要跑这么多次 Sql summary里ident rate指的是每个跑的一样的语句所占比例。比例越高，可优化程度越高 优化方法：DB上设置buffer，不用去表里找，写在缓存里面。abap语句上也可以改进，每次select语句之前，先check while条件有没有改变，没有变化的话，直接用接口从内存里面得到结果 Statistical records不需要trace，就可以看的到response time，wait time，cpu time等等，默认就是开的。T code：STAD，有些公司甚至可以用这个看谁谁谁今天有没有干活，可以看到今天多少人登陆系统，什么时候上班的，最后一次操作什么时候，干了什么事情。但是时间有限，只能保存48小时，平时做服务没问题，跨周末的时候，周五的事到周一就没了，这就很尴尬。]]></content>
      <categories>
        <category>SAP</category>
      </categories>
      <tags>
        <tag>SAP服务</tag>
      </tags>
  </entry>
</search>
